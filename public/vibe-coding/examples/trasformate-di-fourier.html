<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Trasformata di Fourier - Laboratorio Interattivo</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            min-height: 100vh;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.3);
        }

        /* Navbar */
        nav {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            padding: 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        nav ul {
            list-style: none;
            display: flex;
            justify-content: center;
        }

        nav li {
            margin: 0;
        }

        nav button {
            background: transparent;
            border: none;
            color: white;
            padding: 20px 40px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
        }

        nav button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-bottom-color: #3498db;
        }

        nav button.active {
            background: rgba(255, 255, 255, 0.15);
            border-bottom-color: #3498db;
        }

        /* Sezioni */
        .section {
            display: none;
            padding: 30px;
            animation: fadeIn 0.3s ease;
        }

        .section.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 32px;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }

        h2 {
            color: #34495e;
            margin-top: 25px;
            margin-bottom: 15px;
            font-size: 24px;
        }

        h3 {
            color: #555;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 18px;
        }

        /* Bottoni sezione concetti */
        .concept-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .concept-btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 30px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
            text-align: left;
        }

        .concept-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.4);
        }

        .concept-btn small {
            display: block;
            margin-top: 10px;
            font-size: 14px;
            opacity: 0.9;
            font-weight: 400;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            animation: fadeIn 0.3s ease;
        }

        .modal-content {
            background: white;
            margin: 50px auto;
            padding: 40px;
            width: 90%;
            max-width: 900px;
            max-height: 85vh;
            overflow-y: auto;
            border-radius: 15px;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .close-modal {
            float: right;
            font-size: 32px;
            font-weight: bold;
            color: #999;
            cursor: pointer;
            line-height: 1;
            transition: color 0.3s;
        }

        .close-modal:hover {
            color: #333;
        }

        .modal-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #ecf0f1;
        }

        .modal-tab {
            background: transparent;
            border: none;
            padding: 15px 30px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            color: #7f8c8d;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }

        .modal-tab.active {
            color: #3498db;
            border-bottom-color: #3498db;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .formula {
            background: #f8f9fa;
            padding: 20px;
            border-left: 4px solid #3498db;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            overflow-x: auto;
        }

        /* Laboratorio */
        .lab-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        @media (max-width: 1400px) {
            .lab-container {
                grid-template-columns: 1fr;
                gap: 15px;
            }
        }

        @media (max-width: 1200px) {
            .concept-buttons {
                grid-template-columns: 1fr;
            }

            .modal-content {
                width: 95%;
            }
        }

        @media (max-width: 992px) {
            nav button {
                padding: 15px 25px;
                font-size: 15px;
            }

            h1 {
                font-size: 28px;
            }

            .modal-content {
                padding: 25px;
            }
        }

        .lab-column {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            min-width: 0;
        }

        /* Rende i grafici Plotly responsive */
        #timeChart,
        #freqChart {
            width: 100%;
            height: 450px;
            margin-bottom: 20px;
        }

        @media (max-width: 768px) {

            #timeChart,
            #freqChart {
                height: 350px;
            }
        }

        @media (max-width: 480px) {

            #timeChart,
            #freqChart {
                height: 300px;
            }
        }

        @media (max-width: 768px) {
            .lab-column {
                padding: 15px;
            }

            /* Navbar responsive */
            nav ul {
                flex-wrap: wrap;
            }

            nav button {
                padding: 15px 20px;
                font-size: 14px;
            }

            /* Pannelli pi√π compatti */
            .panel {
                padding: 15px;
            }

            .section {
                padding: 15px;
            }

            h1 {
                font-size: 24px;
            }

            h2 {
                font-size: 20px;
            }

            h3 {
                font-size: 16px;
            }

            /* Radio group responsive */
            .radio-group label {
                display: block;
                margin: 8px 0;
            }

            /* Concept buttons responsive */
            .concept-buttons {
                grid-template-columns: 1fr;
            }

            .concept-btn {
                padding: 20px;
                font-size: 16px;
            }

            /* Modal responsive */
            .modal-content {
                margin: 20px auto;
                padding: 20px;
                width: 95%;
                max-height: 90vh;
            }

            .modal-tabs {
                flex-wrap: wrap;
            }

            .modal-tab {
                padding: 10px 15px;
                font-size: 14px;
            }

            /* Grid columns responsive */
            .grid-2col {
                grid-template-columns: 1fr;
            }

            /* Exercise cards */
            .exercise-card {
                padding: 15px;
            }

            /* Sampling controls */
            .sampling-controls {
                padding: 15px;
            }

            /* Formula boxes */
            .formula {
                padding: 15px;
                font-size: 14px;
                overflow-x: auto;
            }
        }

        @media (max-width: 480px) {
            body {
                font-size: 14px;
            }

            .container {
                box-shadow: none;
            }

            /* Navbar mobile */
            nav ul {
                flex-direction: column;
            }

            nav button {
                padding: 12px;
                font-size: 13px;
                width: 100%;
                text-align: left;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }

            nav button.active {
                border-left: 4px solid #3498db;
                border-bottom-color: transparent;
            }

            /* Sezioni */
            .section {
                padding: 10px;
            }

            h1 {
                font-size: 20px;
                margin-bottom: 15px;
            }

            h2 {
                font-size: 18px;
                margin-top: 20px;
                margin-bottom: 12px;
            }

            h3 {
                font-size: 16px;
                margin-top: 15px;
                margin-bottom: 8px;
            }

            p {
                font-size: 14px;
                line-height: 1.6;
            }

            /* Grafici */
            #timeChart,
            #freqChart {
                min-height: 250px;
            }

            /* Bottoni */
            button.btn-primary,
            button.btn-secondary {
                padding: 10px 16px;
                font-size: 14px;
                width: 100%;
                margin-top: 10px;
            }

            .concept-btn {
                padding: 15px;
                font-size: 15px;
            }

            /* Controlli */
            .control-group {
                margin-bottom: 15px;
            }

            .control-group label {
                font-size: 14px;
            }

            input[type="number"],
            input[type="range"] {
                font-size: 14px;
            }

            .slider-value {
                font-size: 14px;
            }

            /* Modal mobile */
            .modal-content {
                margin: 10px;
                padding: 15px;
                width: calc(100% - 20px);
                max-height: 95vh;
            }

            .close-modal {
                font-size: 28px;
            }

            .modal-tabs {
                gap: 5px;
            }

            .modal-tab {
                padding: 8px 12px;
                font-size: 12px;
            }

            /* Pannelli */
            .panel {
                padding: 12px;
            }

            .panel h3 {
                font-size: 16px;
            }

            /* Exercise cards */
            .exercise-card {
                padding: 12px;
            }

            .exercise-card h3 {
                font-size: 16px;
            }

            .exercise-card .objective {
                padding: 12px;
                font-size: 14px;
            }

            /* Sampling controls */
            .sampling-controls {
                padding: 12px;
            }

            .sampling-controls h3 {
                font-size: 16px;
            }

            /* Info boxes */
            .info-box,
            .sync-warning,
            .sync-ok,
            .sync-error {
                padding: 10px;
                font-size: 13px;
            }

            /* Formula */
            .formula {
                padding: 12px;
                font-size: 12px;
            }

            /* Harmonic builder */
            .harmonic-builder {
                padding: 12px;
            }

            .harmonic-builder h4 {
                font-size: 15px;
            }

            /* File input */
            .file-input-wrapper {
                margin-top: 8px;
            }

            input[type="file"] {
                padding: 8px;
                font-size: 12px;
            }

            /* Radio groups pi√π compatti */
            .radio-group label {
                font-size: 14px;
                margin-right: 10px;
                display: inline-block;
                margin-bottom: 8px;
            }
        }

        /* Responsive grids */
        .responsive-grid {
            display: grid;
            gap: 20px;
        }

        @media (max-width: 768px) {
            .responsive-grid {
                grid-template-columns: 1fr !important;
                gap: 15px;
            }
        }

        /* Touch-friendly controls */
        @media (hover: none) and (pointer: coarse) {

            button,
            input[type="radio"],
            input[type="checkbox"] {
                min-height: 44px;
                min-width: 44px;
            }

            .nav-btn {
                min-height: 48px;
            }

            .concept-btn {
                min-height: 60px;
            }

            input[type="range"] {
                height: 44px;
            }
        }

        /* Scrollbar ottimizzato per mobile */
        @media (max-width: 768px) {

            /* Nasconde scrollbar su mobile per aspetto pi√π pulito */
            .modal-content::-webkit-scrollbar {
                width: 4px;
            }

            .modal-content::-webkit-scrollbar-track {
                background: transparent;
            }

            .modal-content::-webkit-scrollbar-thumb {
                background: rgba(0, 0, 0, 0.3);
                border-radius: 2px;
            }
        }

        /* Preset grid responsive */
        @media (max-width: 480px) {
            .preset-grid {
                grid-template-columns: 1fr !important;
            }

            /* Calculator responsive */
            .calculator-box {
                padding: 15px !important;
            }

            .calculator-inputs {
                gap: 12px !important;
            }

            .calculator-box input[type="number"] {
                padding: 10px !important;
                font-size: 14px !important;
            }

            .calculator-box label {
                font-size: 14px !important;
                margin-bottom: 6px !important;
            }

            .calculator-box button {
                max-width: 100% !important;
                padding: 12px 20px !important;
                font-size: 15px !important;
            }

            /* Calculator grid responsive */
            .calculator-grid {
                grid-template-columns: 1fr !important;
            }

            /* Calculator dual responsive */
            .calculator-dual {
                grid-template-columns: 1fr !important;
            }
        }

        @media (max-width: 600px) {
            .calculator-inputs {
                grid-template-columns: 1fr !important;
            }
        }

        @media (max-width: 768px) {

            /* Calculator grid 2 colonne su tablet */
            .calculator-grid {
                grid-template-columns: 1fr 1fr !important;
            }
        }

        @media (max-width: 900px) {

            /* Calculator dual su tablet */
            .calculator-dual {
                grid-template-columns: 1fr !important;
                gap: 15px !important;
            }
        }

        /* Lab-specific styles */
        .lab-params-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .lab-buttons-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .lab-buttons-group button {
            flex: 1;
            min-width: 200px;
        }

        .export-buttons-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .export-buttons-group button {
            width: 100%;
        }

        .signal-type-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 10px 0;
        }

        .signal-type-group label {
            margin: 0;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
            min-width: 120px;
            text-align: center;
        }

        .signal-type-group label:hover {
            background: #e9ecef;
        }

        .signal-type-group input[type="radio"] {
            margin-right: 5px;
            width: 16px;
            height: 16px;
            max-width: 16px;
            max-height: 16px;
            vertical-align: middle;
            transform: scale(1);
            -webkit-appearance: radio;
            appearance: radio;
        }

        @media (max-width: 768px) {
            .lab-params-grid {
                grid-template-columns: 1fr;
            }

            .lab-buttons-group {
                flex-direction: column;
            }

            .lab-buttons-group button {
                width: 100%;
                min-width: auto;
            }

            .signal-type-group {
                flex-direction: column;
            }

            .signal-type-group label {
                min-width: auto;
                text-align: left;
            }
        }

        @media (max-width: 480px) {
            .harmonic-builder {
                padding: 10px;
            }

            .harmonic-builder h4 {
                font-size: 14px;
            }

            .harmonic-builder label {
                font-size: 13px;
            }
        }

        .panel {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .panel h3 {
            margin-top: 0;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }

        input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }

        input[type="radio"] {
            margin-right: 8px;
            width: 16px;
            height: 16px;
            max-width: 16px;
            max-height: 16px;
            vertical-align: middle;
            transform: scale(1);
            -webkit-appearance: radio;
            appearance: radio;
        }

        input[type="number"] {
            width: 100%;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: #3498db;
        }

        .radio-group {
            margin: 10px 0;
        }

        .radio-group label {
            display: inline-block;
            margin-right: 20px;
            cursor: pointer;
        }

        .slider-value {
            display: inline-block;
            margin-left: 10px;
            font-weight: bold;
            color: #3498db;
        }

        button.btn-primary {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
        }

        button.btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
        }

        button.btn-secondary {
            background: #95a5a6;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button.btn-secondary:hover {
            background: #7f8c8d;
        }

        .file-input-wrapper {
            margin-top: 10px;
        }

        input[type="file"] {
            padding: 10px;
            border: 2px dashed #3498db;
            border-radius: 6px;
            cursor: pointer;
            width: 100%;
        }

        /* Esercizi */
        .exercise-card {
            background: white;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 25px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border-left: 5px solid #3498db;
        }

        .exercise-card h3 {
            color: #2c3e50;
            margin-bottom: 15px;
        }

        .exercise-card .objective {
            background: #e8f4f8;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            font-weight: 600;
            color: #2980b9;
        }

        .exercise-card .instructions {
            line-height: 1.8;
            color: #555;
        }

        .exercise-card button {
            margin-top: 15px;
        }

        #timeChart,
        #freqChart {
            width: 100%;
            height: 400px;
        }

        .harmonic-builder {
            border: 1px solid #ddd;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 6px;
            background: #fafafa;
        }

        .harmonic-builder h4 {
            color: #34495e;
            margin-bottom: 10px;
        }

        /* Controlli campionamento */
        .sampling-controls {
            background: #fff8dc;
            border: 2px solid #f39c12;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .sampling-controls h3 {
            color: #d68910;
            margin-top: 0;
            border-bottom: 2px solid #f39c12;
        }

        .sync-warning {
            background: #fff3cd;
            border-left: 4px solid #f0ad4e;
            padding: 12px;
            margin: 15px 0;
            border-radius: 4px;
            font-size: 14px;
            color: #856404;
        }

        .sync-ok {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 12px;
            margin: 15px 0;
            border-radius: 4px;
            font-size: 14px;
            color: #155724;
        }

        .sync-error {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 12px;
            margin: 15px 0;
            border-radius: 4px;
            font-size: 14px;
            color: #721c24;
        }

        .grid-2col {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }

        .info-box {
            background: #e8f4f8;
            padding: 12px;
            border-radius: 6px;
            font-size: 14px;
            margin-top: 10px;
        }

        .info-box strong {
            color: #2980b9;
        }

        /* Responsive grids */
        .responsive-grid {
            display: grid;
            gap: 20px;
        }

        @media (max-width: 768px) {
            .responsive-grid {
                grid-template-columns: 1fr !important;
                gap: 15px;
            }
        }

        /* Touch-friendly controls */
        @media (hover: none) and (pointer: coarse) {

            button,
            input[type="radio"],
            input[type="checkbox"] {
                min-height: 44px;
                min-width: 44px;
            }

            .nav-btn {
                min-height: 48px;
            }

            .concept-btn {
                min-height: 60px;
            }
        }

        /* Scrollbar ottimizzato per mobile */
        @media (max-width: 768px) {

            /* Nasconde scrollbar su mobile per aspetto pi√π pulito */
            .modal-content::-webkit-scrollbar {
                width: 4px;
            }

            .modal-content::-webkit-scrollbar-track {
                background: transparent;
            }

            .modal-content::-webkit-scrollbar-thumb {
                background: rgba(0, 0, 0, 0.3);
                border-radius: 2px;
            }
        }

        /* Preset grid responsive */
        @media (max-width: 480px) {
            .preset-grid {
                grid-template-columns: 1fr !important;
            }

            /* Calculator responsive */
            .calculator-box {
                padding: 15px !important;
            }

            .calculator-inputs {
                gap: 12px !important;
            }

            .calculator-box input[type="number"] {
                padding: 10px !important;
                font-size: 14px !important;
            }

            .calculator-box label {
                font-size: 14px !important;
                margin-bottom: 6px !important;
            }

            .calculator-box button {
                max-width: 100% !important;
                padding: 12px 20px !important;
                font-size: 15px !important;
            }

            /* Calculator grid responsive */
            .calculator-grid {
                grid-template-columns: 1fr !important;
            }

            /* Calculator dual responsive */
            .calculator-dual {
                grid-template-columns: 1fr !important;
            }
        }

        @media (max-width: 600px) {
            .calculator-inputs {
                grid-template-columns: 1fr !important;
            }
        }

        @media (max-width: 768px) {

            /* Calculator grid 2 colonne su tablet */
            .calculator-grid {
                grid-template-columns: 1fr 1fr !important;
            }
        }

        @media (max-width: 900px) {

            /* Calculator dual su tablet */
            .calculator-dual {
                grid-template-columns: 1fr !important;
                gap: 15px !important;
            }
        }

        /* Lab-specific styles */
        .lab-params-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .lab-buttons-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .lab-buttons-group button {
            flex: 1;
            min-width: 200px;
        }

        .export-buttons-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .export-buttons-group button {
            width: 100%;
        }

        .signal-type-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 10px 0;
        }

        .signal-type-group label {
            margin: 0;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
            min-width: 120px;
            text-align: center;
        }

        .signal-type-group label:hover {
            background: #e9ecef;
        }

        .signal-type-group input[type="radio"] {
            margin-right: 5px;
            width: 16px;
            height: 16px;
            max-width: 16px;
            max-height: 16px;
            vertical-align: middle;
            transform: scale(1);
            -webkit-appearance: radio;
            appearance: radio;
        }

        @media (max-width: 768px) {
            .lab-params-grid {
                grid-template-columns: 1fr;
            }

            .lab-buttons-group {
                flex-direction: column;
            }

            .lab-buttons-group button {
                width: 100%;
                min-width: auto;
            }

            .signal-type-group {
                flex-direction: column;
            }

            .signal-type-group label {
                min-width: auto;
                text-align: left;
            }
        }

        @media (max-width: 480px) {
            .harmonic-builder {
                padding: 10px;
            }

            .harmonic-builder h4 {
                font-size: 14px;
            }

            .harmonic-builder label {
                font-size: 13px;
            }

            /* Fix per bottoni dentro i pannelli su mobile */
            .panel .btn-primary,
            .panel .btn-secondary {
                width: 100% !important;
                margin-left: 0 !important;
                margin-right: 0 !important;
            }
        }

        /* Classi per sostituire stili inline */
        .intro-text {
            font-size: 18px;
            line-height: 1.8;
            color: #555;
            margin-bottom: 30px;
        }

        .section-text {
            font-size: 16px;
            line-height: 1.8;
            color: #555;
            margin-bottom: 20px;
        }

        .description-text {
            font-size: 14px;
            color: #666;
            margin-bottom: 15px;
        }

        .small-text {
            font-size: 13px;
            color: #666;
            margin-bottom: 15px;
            line-height: 1.6;
        }

        .info-text {
            font-size: 13px;
            color: #666;
            margin-top: 8px;
            margin-left: 24px;
        }

        .help-text {
            font-size: 12px;
            color: #666;
            margin-top: 8px;
            line-height: 1.5;
        }

        .control-group-spaced {
            margin-top: 15px;
        }

        .preset-section {
            margin-top: 25px;
            padding-top: 20px;
            border-top: 2px solid #e0e0e0;
        }

        .preset-title {
            color: #2980b9;
            margin-bottom: 10px;
        }

        .preset-info {
            margin-top: 12px;
            padding: 12px;
            background: #e8f4f8;
            border-radius: 6px;
            border-left: 4px solid #3498db;
            display: none;
        }

        .preset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .preset-grid button {
            width: 100%;
            text-align: left;
            padding: 12px 16px;
        }

        .window-panel {
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            border-left: 4px solid #f39c12;
        }

        .window-title {
            color: #d68910;
        }

        .window-label {
            font-weight: 600;
            color: #d68910;
        }

        .window-select {
            width: 100%;
            padding: 10px;
            border: 2px solid #f39c12;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            cursor: pointer;
        }

        .window-info {
            margin-top: 15px;
            padding: 12px;
            background: #fff9e6;
            border-radius: 6px;
            border-left: 4px solid #f39c12;
            display: none;
        }

        .window-info-title {
            color: #d68910;
        }

        .window-description {
            margin-top: 8px;
            color: #555;
        }

        .comparison-panel {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .comparison-title {
            color: #856404;
        }

        .exercise-warning {
            border-left-color: #f39c12;
        }

        .exercise-objective {
            background: #fff9e6;
            color: #d68910;
        }

        .application-box {
            background: #e8f4f8;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .application-item {
            margin-bottom: 15px;
        }

        .list-formatted {
            line-height: 1.8;
            font-size: 16px;
        }

        .btn-spaced {
            margin-top: 8px;
        }

        .btn-bottom-spaced {
            margin-bottom: 15px;
        }
    </style>
</head>

<body>
    <div class="container">
        <nav>
            <ul>
                <li><button class="nav-btn active" data-section="concetti">Concetti</button></li>
                <li><button class="nav-btn" data-section="laboratorio">Laboratorio Virtuale</button></li>
                <li><button class="nav-btn" data-section="esercizi">Esercitazioni</button></li>
            </ul>
        </nav>

        <!-- SEZIONE CONCETTI -->
        <section id="concetti" class="section active">
            <h1>üéì Concetti Fondamentali della Trasformata di Fourier</h1>
            <p class="intro-text">
                La Trasformata di Fourier √® uno degli strumenti matematici pi√π potenti dell'ingegneria e della fisica.
                Permette di "vedere" un segnale da una prospettiva completamente diversa: invece di guardare come cambia
                nel tempo,
                possiamo scoprire di quali frequenze √® composto. Clicca sui pulsanti qui sotto per esplorare i concetti
                chiave.
            </p>

            <div class="concept-buttons">
                <button class="concept-btn" onclick="openModal('modal1')">
                    üéØ A cosa serve?
                    <small>Scopri le applicazioni pratiche della Trasformata di Fourier</small>
                </button>
                <button class="concept-btn" onclick="openModal('modal2')">
                    üîÑ Dal Tempo alla Frequenza
                    <small>Visualizza la "magia" della conversione tra domini</small>
                </button>
                <button class="concept-btn" onclick="openModal('modal3')">
                    üìê Le Formule (Spiegazione Duplice)
                    <small>Dalla Serie (sommatoria) alla Trasformata (integrale)</small>
                </button>
            </div>
        </section>

        <!-- SEZIONE LABORATORIO -->
        <section id="laboratorio" class="section">
            <h1>üî¨ Laboratorio Virtuale</h1>
            <p class="section-text">
                Sperimenta in tempo reale con segnali e osserva il loro spettro in frequenza.
            </p>

            <!-- CONTROLLI CAMPIONAMENTO -->
            <div class="sampling-controls">
                <h3>‚öôÔ∏è Parametri di Campionamento</h3>
                <p class="description-text">
                    Controlla la frequenza di campionamento e il numero di campioni per osservare gli effetti del
                    windowing e dell'aliasing.
                </p>

                <div class="grid-2col lab-params-grid">
                    <div class="control-group">
                        <label>Frequenza di Campionamento (Hz):</label>
                        <input type="number" id="sampleRateInput" value="8000" min="10" max="10000000" step="1">
                        <div class="info-box">
                            <strong>Teorema di Nyquist:</strong> Fs deve essere almeno 2√ó la frequenza massima del
                            segnale
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Numero di Campioni:</label>
                        <input type="number" id="numSamplesInput" value="1024" min="64" max="16384" step="1">
                        <div class="info-box">
                            Potenze di 2 comuni: 128, 256, 512, <strong>1024</strong>, 2048, 4096, 8192
                        </div>
                    </div>
                </div>

                <div class="control-group control-group-spaced">
                    <label>
                        <input type="checkbox" id="syncSamplingCheck" checked>
                        <strong>Campionamento Sincrono</strong> (numero intero di campioni per periodo)
                    </label>
                    <p class="info-text">
                        Quando attivo, il numero di campioni viene automaticamente calcolato per catturare un numero
                        intero di periodi del segnale fondamentale, riducendo gli effetti del windowing.
                    </p>
                    <button class="btn-secondary" onclick="openModal('modalPowerOf2')" class="btn-spaced">
                        ‚ÑπÔ∏è Perch√© Potenze di 2?
                    </button>
                </div>

                <div id="samplingStatus"></div>

                <div class="lab-buttons-group">
                    <button class="btn-primary" onclick="applySamplingSettings()">
                        Applica Impostazioni di Campionamento
                    </button>
                    <button class="btn-secondary" onclick="openModal('modalSamplingGuide')">
                        üìä Guida al Campionamento
                    </button>
                </div>

                <!-- PRESET DIDATTICI -->
                <div class="control-group preset-section">
                    <h4 class="preset-title">üéØ Preset Didattici</h4>
                    <p>
                        Carica rapidamente configurazioni tipiche usate in applicazioni reali:
                    </p>
                    <div class="preset-grid">
                        <button class="btn-secondary" onclick="loadPreset('audio-cd')">
                            üéµ Audio CD (44.1 kHz)
                        </button>
                        <button class="btn-secondary" onclick="loadPreset('audio-hd')">
                            üéß Audio HD (48 kHz)
                        </button>
                        <button class="btn-secondary" onclick="loadPreset('telephony')">
                            üìû Telefonia (8 kHz)
                        </button>
                        <button class="btn-secondary" onclick="loadPreset('ultrasound')">
                            ü©∫ Ultrasuoni (1 MHz)
                        </button>
                        <button class="btn-secondary" onclick="loadPreset('seismic')">
                            üåä Sismico (100 Hz)
                        </button>
                        <button class="btn-secondary" onclick="loadPreset('eeg')">
                            üß† EEG (256 Hz)
                        </button>
                        <button class="btn-secondary" onclick="loadPreset('radar')">
                            üì° Radar (10 kHz)
                        </button>
                        <button class="btn-secondary" onclick="loadPreset('vibration')">
                            ‚öôÔ∏è Vibrazioni (2 kHz)
                        </button>
                    </div>
                    <div id="presetInfo">
                    </div>
                </div>
            </div>

            <div class="lab-container">
                <!-- COLONNA SINISTRA: Dominio del Tempo -->
                <div class="lab-column">
                    <h2>‚è±Ô∏è Dominio del Tempo</h2>
                    <div id="timeChart"></div>

                    <!-- Generatore Segnali Predefiniti -->
                    <div class="panel">
                        <h3>Generatore di Segnali</h3>
                        <div class="control-group">
                            <label>Frequenza Segnale (Hz):</label>
                            <input type="number" id="signalFreqInput" value="100" min="0.1" max="1000000" step="0.1">
                        </div>
                        <div class="radio-group signal-type-group">
                            <label><input type="radio" name="signalType" value="sine" checked> Sinusoide</label>
                            <label><input type="radio" name="signalType" value="square"> Onda Quadra</label>
                            <label><input type="radio" name="signalType" value="triangle"> Onda Triangolare</label>
                            <label><input type="radio" name="signalType" value="noise"> Rumore Bianco</label>
                        </div>
                        <button class="btn-primary" onclick="generatePredefinedSignal()">Genera Segnale</button>
                    </div>

                    <!-- Costruttore Segnali -->
                    <div class="panel">
                        <h3>Costruttore di Segnali</h3>
                        <p class="description-text">
                            Crea un segnale personalizzato sommando fino a 3 sinusoidi. Il grafico si aggiorna in tempo
                            reale!
                        </p>

                        <div class="harmonic-builder">
                            <h4>Fondamentale</h4>
                            <label>Ampiezza: <span class="slider-value" id="amp1-val">0.50</span></label>
                            <input type="range" id="amp1" min="0" max="1" step="0.01" value="0.5"
                                oninput="updateCustomSignal()">
                            <label>Frequenza (Hz): <span class="slider-value" id="freq1-val">100</span></label>
                            <input type="range" id="freq1" min="0" max="1000" step="1" value="100"
                                oninput="updateCustomSignal()">
                            <label>Fase (¬∞): <span class="slider-value" id="phase1-val">0</span></label>
                            <input type="range" id="phase1" min="0" max="360" step="1" value="0"
                                oninput="updateCustomSignal()">
                        </div>

                        <div class="harmonic-builder">
                            <h4>Armonica 1</h4>
                            <label>Ampiezza: <span class="slider-value" id="amp2-val">0.00</span></label>
                            <input type="range" id="amp2" min="0" max="1" step="0.01" value="0"
                                oninput="updateCustomSignal()">
                            <label>Frequenza (Hz): <span class="slider-value" id="freq2-val">200</span></label>
                            <input type="range" id="freq2" min="0" max="1000" step="1" value="200"
                                oninput="updateCustomSignal()">
                            <label>Fase (¬∞): <span class="slider-value" id="phase2-val">0</span></label>
                            <input type="range" id="phase2" min="0" max="360" step="1" value="0"
                                oninput="updateCustomSignal()">
                        </div>

                        <div class="harmonic-builder">
                            <h4>Armonica 2</h4>
                            <label>Ampiezza: <span class="slider-value" id="amp3-val">0.00</span></label>
                            <input type="range" id="amp3" min="0" max="1" step="0.01" value="0"
                                oninput="updateCustomSignal()">
                            <label>Frequenza (Hz): <span class="slider-value" id="freq3-val">300</span></label>
                            <input type="range" id="freq3" min="0" max="1000" step="1" value="300"
                                oninput="updateCustomSignal()">
                            <label>Fase (¬∞): <span class="slider-value" id="phase3-val">0</span></label>
                            <input type="range" id="phase3" min="0" max="360" step="1" value="0"
                                oninput="updateCustomSignal()">
                        </div>
                    </div>

                    <!-- Importa Dati -->
                    <div class="panel">
                        <h3>Importa Dati</h3>
                        <div class="radio-group">
                            <label><input type="radio" name="fileFormat" value="csv" checked> CSV Semplice (tempo,
                                valore)</label><br>
                            <label><input type="radio" name="fileFormat" value="picoscope"> Picoscope PSData
                                (.txt/.csv)</label>
                        </div>
                        <div class="file-input-wrapper">
                            <input type="file" id="fileImport" accept=".csv,.txt">
                        </div>
                    </div>

                    <!-- Windowing Functions -->
                    <div class="panel">
                        <h3 class="window-title">ü™ü Funzioni di Finestra (Windowing)</h3>
                        <p class="small-text">
                            Le funzioni di finestra riducono il leakage spettrale attenuando il segnale ai bordi.
                            Seleziona una finestra e osserva l'effetto sul segnale e sullo spettro!
                        </p>

                        <div class="control-group">
                            <label class="window-label">Tipo di Finestra:</label>
                            <select id="windowType" onchange="applyWindowFunction()">
                                <option value="rectangular">Rettangolare (Nessuna)</option>
                                <option value="hanning">Hanning (von Hann)</option>
                                <option value="hamming">Hamming</option>
                                <option value="blackman">Blackman</option>
                                <option value="bartlett">Bartlett (Triangolare)</option>
                                <option value="kaiser">Kaiser (Œ≤=5)</option>
                            </select>
                        </div>

                        <button class="btn-primary" onclick="applyWindowFunction()">
                            üîÑ Applica Finestra
                        </button>

                        <div id="windowInfo">
                            <strong class="window-info-title">‚ÑπÔ∏è Info Finestra:</strong>
                            <div id="windowDescription" class="window-description"></div>
                        </div>

                        <button class="btn-secondary" onclick="showWindowComparison()">
                            üìä Confronta Tutte le Finestre
                        </button>

                        <button class="btn-primary" onclick="openModal('modalWindowTheory')">
                            üìö Teoria delle Finestre
                        </button>
                    </div>
                </div>

                <!-- COLONNA DESTRA: Dominio della Frequenza -->
                <div class="lab-column">
                    <h2>üìä Dominio della Frequenza</h2>
                    <div class="radio-group">
                        <label><input type="radio" name="scaleType" value="linear" checked
                                onchange="updateFrequencyPlot()"> Scala Lineare</label>
                        <label><input type="radio" name="scaleType" value="log" onchange="updateFrequencyPlot()"> Scala
                            Logaritmica (dB)</label>
                    </div>
                    <div id="freqChart"></div>

                    <div class="panel">
                        <h3>Esporta Dati</h3>
                        <div class="export-buttons-group">
                            <button class="btn-primary" onclick="exportSpectrum()">
                                üì• Esporta Spettro (CSV)
                            </button>
                            <button class="btn-primary" onclick="exportWithParameters()">
                                üìä Esporta Spettro + Parametri
                            </button>
                        </div>
                        <p class="help-text">
                            Il secondo export include tutti i parametri di campionamento usati per generare lo spettro.
                        </p>
                    </div>

                    <div class="panel comparison-panel">
                        <h3 class="comparison-title">üìä Confronto Campionamento</h3>
                        <p class="small-text">
                            Visualizza side-by-side lo spettro con campionamento sincrono (senza leakage) e
                            non sincrono (con leakage) per confrontare gli effetti.
                        </p>
                        <button class="btn-primary" onclick="showSyncComparison()">
                            üîç Mostra Confronto Side-by-Side
                        </button>
                    </div>
                </div>
            </div>
        </section>

        <!-- SEZIONE ESERCIZI -->
        <section id="esercizi" class="section">
            <h1>üìö Esercitazioni Guidate</h1>
            <p>
                Metti in pratica i concetti attraverso esercizi guidati. Ogni esercizio pre-configura il Laboratorio
                Virtuale
                con parametri specifici per aiutarti a esplorare fenomeni importanti.
            </p>

            <div class="exercise-card">
                <h3>üîß Esercizio 1: Costruisci un'Onda Quadra</h3>
                <div class="objective">
                    <strong>Obiettivo:</strong> Capire la Serie di Fourier e come un'onda complessa sia la somma di
                    sinusoidi.
                </div>
                <div class="instructions">
                    <p><strong>Teoria:</strong> Un'onda quadra pu√≤ essere ricostruita sommando una sinusoide
                        fondamentale e le sue armoniche dispari (3f, 5f, 7f...) con ampiezze decrescenti (1, 1/3, 1/5,
                        1/7...).</p>
                    <p><strong>Istruzioni:</strong></p>
                    <ol>
                        <li>Vai alla sezione "Laboratorio Virtuale"</li>
                        <li>Nel pannello "Costruttore di Segnali", imposta:
                            <ul>
                                <li><strong>Fondamentale:</strong> Ampiezza = 1.0, Frequenza = 50 Hz, Fase = 0¬∞</li>
                                <li><strong>Armonica 1:</strong> Ampiezza = 0.33 (1/3), Frequenza = 150 Hz (3√ó50), Fase
                                    = 0¬∞</li>
                                <li><strong>Armonica 2:</strong> Ampiezza = 0.20 (1/5), Frequenza = 250 Hz (5√ó50), Fase
                                    = 0¬∞</li>
                            </ul>
                        </li>
                        <li>Osserva come il segnale nel dominio del tempo inizia ad assomigliare a un'onda quadra</li>
                        <li>Guarda lo spettro: vedrai 3 picchi distinti alle frequenze 50, 150 e 250 Hz</li>
                    </ol>
                    <p><strong>Domanda di riflessione:</strong> Cosa succederebbe se aggiungessi anche la settima
                        armonica (7√ó50 = 350 Hz) con ampiezza 1/7?</p>
                </div>
                <button class="btn-primary" onclick="setupExercise1()">Configura Esercizio</button>
            </div>

            <div class="exercise-card">
                <h3>üîç Esercizio 2: Identifica il Disturbo</h3>
                <div class="objective">
                    <strong>Obiettivo:</strong> Imparare a leggere uno spettro e identificare frequenze indesiderate.
                </div>
                <div class="instructions">
                    <p><strong>Scenario:</strong> Hai registrato un segnale audio, ma durante l'acquisizione si √®
                        introdotto un disturbo elettrico dalla rete elettrica e un po' di rumore casuale.</p>
                    <p><strong>Istruzioni:</strong></p>
                    <ol>
                        <li>Clicca su "Carica Segnale Disturbato" per caricare il segnale nel Laboratorio</li>
                        <li>Osserva il grafico nel dominio del tempo: il segnale sembra "sporco"</li>
                        <li>Passa al dominio della frequenza e identifica:
                            <ul>
                                <li>Il picco pi√π alto (il segnale utile)</li>
                                <li>Il secondo picco (il disturbo dalla rete elettrica a 50 Hz)</li>
                                <li>Il "rumore di fondo" diffuso su tutte le frequenze</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>Domande:</strong></p>
                    <ul>
                        <li>A quale frequenza si trova il segnale utile?</li>
                        <li>Quale frequenza corrisponde al disturbo della rete elettrica?</li>
                        <li>Quale dei due picchi ha ampiezza maggiore?</li>
                    </ul>
                </div>
                <button class="btn-primary" onclick="setupExercise2()">Carica Segnale Disturbato</button>
            </div>

            <div class="exercise-card">
                <h3>üéöÔ∏è Esercizio 3: L'Effetto del Filtro (Simulato)</h3>
                <div class="objective">
                    <strong>Obiettivo:</strong> Capire come funziona il filtraggio in frequenza e il suo effetto nel
                    tempo.
                </div>
                <div class="instructions">
                    <p><strong>Teoria:</strong> Un filtro passa-basso "taglia" tutte le frequenze sopra una certa
                        soglia, lasciando passare solo quelle basse. Questo √® usato per eliminare rumori ad alta
                        frequenza o per "smussare" segnali.</p>
                    <p><strong>Istruzioni:</strong></p>
                    <ol>
                        <li>Clicca su "Genera Onda Quadra" per caricare un'onda quadra a 100 Hz nel Laboratorio</li>
                        <li>Guarda lo spettro: l'onda quadra ha molte armoniche (picchi a 100, 300, 500, 700 Hz...)</li>
                        <li>Ora immagina di applicare un "filtro passa-basso" che elimina tutte le frequenze sopra 150
                            Hz</li>
                        <li>Nel "Costruttore di Segnali", imposta:
                            <ul>
                                <li><strong>Fondamentale:</strong> Ampiezza = 1.0, Frequenza = 100 Hz (l'unica che passa
                                    il filtro)</li>
                                <li><strong>Armonica 1 e 2:</strong> Ampiezza = 0 (simulate le frequenze eliminate dal
                                    filtro)</li>
                            </ul>
                        </li>
                        <li>Cosa vedi nel dominio del tempo? Una sinusoide pura!</li>
                    </ol>
                    <p><strong>Conclusione:</strong> Filtrare in frequenza (eliminare armoniche) modifica la forma
                        d'onda nel tempo. Un'onda quadra "filtrata" diventa una sinusoide.</p>
                </div>
                <button class="btn-primary" onclick="setupExercise3()">Genera Onda Quadra</button>
            </div>

            <div class="exercise-card">
                <h3>üìê Esercizio 4: Effetti del Windowing</h3>
                <div class="objective">
                    <strong>Obiettivo:</strong> Osservare come il campionamento non sincrono crea leakage spettrale.
                </div>
                <div class="instructions">
                    <p><strong>Teoria:</strong> Quando il numero di campioni non cattura un numero intero di periodi del
                        segnale, si verifica il fenomeno del "windowing" o "leakage spettrale": l'energia di una singola
                        frequenza si "diffonde" su pi√π bin dello spettro.</p>
                    <p><strong>Istruzioni:</strong></p>
                    <ol>
                        <li>Nei "Parametri di Campionamento", attiva il <strong>Campionamento Sincrono</strong></li>
                        <li>Genera una sinusoide a 100 Hz</li>
                        <li>Osserva lo spettro: vedrai un unico picco netto a 100 Hz</li>
                        <li>Ora <strong>disattiva il Campionamento Sincrono</strong></li>
                        <li>Cambia la frequenza di campionamento o il numero di campioni</li>
                        <li>Osserva come il picco si "allarga" e compaiono lobi laterali (leakage)</li>
                    </ol>
                    <p><strong>Conclusione:</strong> Il campionamento sincrono √® fondamentale per ottenere spettri
                        puliti. Negli strumenti reali, si usano finestre (Hanning, Hamming, Blackman) per ridurre il
                        leakage quando il campionamento sincrono non √® possibile.</p>
                </div>
                <button class="btn-primary" onclick="setupExercise4()">Configura Esercizio Windowing</button>
            </div>

            <div class="exercise-card exercise-warning">
                <h3>ü™ü Esercizio 5: Confronto Funzioni di Finestra</h3>
                <div class="objective exercise-objective">
                    <strong>Obiettivo:</strong> Sperimentare diverse finestre e capire il compromesso tra risoluzione e
                    riduzione del leakage.
                </div>
                <div class="instructions">
                    <p><strong>Teoria:</strong> Le funzioni di finestra sono "pesi" moltiplicativi che attenuano il
                        segnale
                        ai bordi, riducendo la discontinuit√† quando il campionamento non √® sincrono. Ogni finestra ha
                        caratteristiche diverse.</p>
                    <p><strong>Istruzioni:</strong></p>
                    <ol>
                        <li>Genera una sinusoide a 100 Hz con campionamento <strong>non sincrono</strong> (es. 950
                            campioni)</li>
                        <li>Nella sezione "Funzioni di Finestra", seleziona <strong>Rettangolare (Nessuna)</strong> e
                            osserva il leakage</li>
                        <li>Prova le diverse finestre una per una:
                            <ul>
                                <li><strong>Hanning:</strong> Buon compromesso generale</li>
                                <li><strong>Hamming:</strong> Migliore soppressione lobi laterali</li>
                                <li><strong>Blackman:</strong> Massima riduzione del leakage (picco pi√π largo)</li>
                            </ul>
                        </li>
                        <li>Osserva come cambia lo spettro: il leakage diminuisce ma il picco principale si allarga</li>
                        <li>Clicca su "Confronta Tutte le Finestre" per vedere le differenze</li>
                    </ol>
                    <p><strong>Domanda di riflessione:</strong> Quale finestra useresti per identificare frequenze molto
                        vicine?
                        E quale per minimizzare interferenze da frequenze lontane?</p>
                </div>
                <button class="btn-primary" onclick="setupExercise5()">
                    Configura Esercizio Finestre
                </button>
            </div>
        </section>
    </div>

    <!-- MODALI -->
    <div id="modal1" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('modal1')">&times;</span>
            <h2>üéØ A cosa serve la Trasformata di Fourier?</h2>

            <h3>La "Ricetta" di un Segnale</h3>
            <p class="list-formatted">
                Immagina di ascoltare un accordo musicale. Le tue orecchie non sentono un "suono unico", ma riescono a
                distinguere
                le singole note che lo compongono (Do, Mi, Sol...). La Trasformata di Fourier fa esattamente questo con
                qualsiasi segnale:
                ci dice <strong>quali frequenze contiene</strong> e <strong>quanto √® forte ciascuna di esse</strong>.
            </p>

            <h3>L'Analogia della Cucina</h3>
            <p class="list-formatted">
                Se un piatto cucinato √® il "segnale nel tempo" (quello che mangi), la Trasformata di Fourier √® la sua
                <strong>ricetta</strong>:
                l'elenco degli ingredienti (frequenze) e le loro quantit√† (ampiezze). Conoscere la ricetta ti permette
                di:
            </p>
            <ul class="list-formatted">
                <li>Capire di cosa √® fatto il piatto</li>
                <li>Togliere ingredienti che non ti piacciono (filtraggio)</li>
                <li>Ricrearlo da zero con ingredienti diversi</li>
            </ul>

            <h3>Applicazioni Reali</h3>
            <div class="application-box">
                <p class="btn-bottom-spaced"><strong>üéµ Compressione Audio (MP3, AAC):</strong> Gli algoritmi
                    identificano le frequenze che l'orecchio umano sente poco e le eliminano, riducendo la dimensione
                    del file senza perdita percepibile di qualit√†.</p>

                <p class="btn-bottom-spaced"><strong>üì° Telecomunicazioni (Wi-Fi, 4G, 5G):</strong> I segnali vengono
                    trasmessi su specifiche bande di frequenza. La FT permette di "impacchettare" pi√π comunicazioni su
                    frequenze diverse senza interferenze.</p>

                <p class="btn-bottom-spaced"><strong>ü©∫ Analisi Medica (ECG, EEG):</strong> I medici usano lo spettro
                    per identificare anomalie: per esempio, certe frequenze anomale nel battito cardiaco possono
                    indicare aritmie.</p>

                <p class="btn-bottom-spaced"><strong>üé∏ Effetti Audio (Equalizzatori):</strong> Quando aumenti i
                    "bassi" o gli "alti" con un equalizzatore, stai modificando l'ampiezza di specifiche bande di
                    frequenza.</p>

                <p><strong>üî¨ Analisi di Segnali (Oscilloscopi Digitali):</strong> Gli ingegneri usano la FT per
                    identificare disturbi, risonanze o armoniche indesiderate nei circuiti elettronici.</p>
            </div>

            <h3>Perch√© √® cos√¨ Importante?</h3>
            <p class="list-formatted">
                Molti fenomeni sono <strong>pi√π facili da capire e manipolare nel dominio della frequenza</strong> che
                nel dominio del tempo.
                Per esempio: rimuovere un fischio a 1000 Hz da una registrazione audio √® semplicissimo nello spettro (si
                elimina quella frequenza),
                ma sarebbe quasi impossibile lavorando direttamente sulla forma d'onda temporale.
            </p>

            <!-- CALCOLATORE INTERATTIVO -->
            <div class="calculator-box">
                <h3>üßÆ Calcolatore: Risoluzione in Frequenza</h3>
                <p>
                    La risoluzione in frequenza (Œîf) √® la distanza minima tra due frequenze distinguibili nello spettro.
                    Dipende dalla frequenza di campionamento e dal numero di campioni.
                </p>

                <div class="calculator-inputs responsive-grid">
                    <div>
                        <label>Frequenza
                            di Campionamento (Hz):</label>
                        <input type="number" id="calc1_fs" value="8000" min="100" max="100000">
                    </div>
                    <div>
                        <label>Numero di
                            Campioni:</label>
                        <input type="number" id="calc1_n" value="1024" min="64" max="16384">
                    </div>
                </div>

                <button onclick="calculateResolution()" class="btn-primary">
                    Calcola Risoluzione
                </button>

                <div id="calc1_result">
                    <h4>üìä Risultati:</h4>
                    <div>
                        <p><strong>Risoluzione in frequenza (Œîf):</strong> <span id="calc1_delta_f"></span></p>
                        <p><strong>Durata della finestra temporale:</strong> <span id="calc1_duration"></span></p>
                        <p><strong>Frequenza massima rilevabile (Nyquist):</strong> <span id="calc1_nyquist"></span></p>
                        <p>
                            <strong>üí° Interpretazione:</strong> <span id="calc1_interpretation"></span>
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="modal2" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('modal2')">&times;</span>
            <h2>üîÑ Dal Tempo alla Frequenza</h2>

            <p>
                La Trasformata di Fourier "converte" la rappresentazione di un segnale da una visualizzazione all'altra.
                √à come guardare un oggetto da due angolazioni diverse: ognuna rivela informazioni che l'altra nasconde.
            </p>

            <div class="responsive-grid">
                <div>
                    <h3>Dominio del Tempo</h3>
                    <p><strong>Asse X:</strong> Tempo (secondi)</p>
                    <p><strong>Asse Y:</strong> Ampiezza (Volt, Ampere...)</p>
                    <p><strong>Mostra:</strong> Come varia il segnale istante per istante</p>
                    <p><strong>Esempio:</strong> La forma d'onda che vedi su un oscilloscopio</p>
                </div>
                <div>
                    <h3>Dominio della Frequenza</h3>
                    <p><strong>Asse X:</strong> Frequenza (Hertz)</p>
                    <p><strong>Asse Y:</strong> Ampiezza (intensit√† di ogni frequenza)</p>
                    <p><strong>Mostra:</strong> Quali frequenze compongono il segnale</p>
                    <p><strong>Esempio:</strong> Lo spettro che vedi su un analizzatore di spettro</p>
                </div>
            </div>

            <h3>Esempio Visivo: Onda Quadra</h3>
            <div>
                <p class="btn-bottom-spaced"><strong>Nel dominio del TEMPO:</strong> Vedi un'onda che sale e scende
                    bruscamente, formando "gradini" regolari. √à difficile capire immediatamente di quali componenti √®
                    fatta.</p>

                <p class="btn-bottom-spaced"><strong>Nel dominio della FREQUENZA:</strong> Vedi una serie di "picchi"
                    (chiamati armoniche):
                <ul>
                    <li>Un picco grande alla frequenza fondamentale (es. 100 Hz)</li>
                    <li>Picchi pi√π piccoli alle armoniche dispari: 300 Hz (3√ó), 500 Hz (5√ó), 700 Hz (7√ó)...</li>
                    <li>Nessun picco alle armoniche pari (200 Hz, 400 Hz...)</li>
                </ul>
                </p>

                <p><strong>Rivelazione:</strong> Ora √® chiaro che l'onda quadra √® una <strong>somma di sinusoidi a
                        frequenze dispari</strong>.
                    Questa informazione √® nascosta nel dominio del tempo, ma evidente nel dominio della frequenza!</p>
            </div>

            <h3>La "Magia" della Conversione</h3>
            <p class="list-formatted">
                Non si perde alcuna informazione nel passaggio: il segnale nel tempo e il suo spettro in frequenza
                contengono
                <strong>esattamente gli stessi dati</strong>, semplicemente organizzati in modo diverso. Puoi sempre
                tornare indietro
                usando la <strong>Trasformata Inversa di Fourier</strong> (che riconverte frequenza ‚Üí tempo).
            </p>

            <div>
                <p>
                    üí° Analogia Utile
                </p>
                <p>
                    √à come la differenza tra leggere uno spartito musicale (frequenze: note e loro durate)
                    e ascoltare la musica (tempo: suono che varia istante per istante).
                    Sono due modi di rappresentare la stessa informazione!
                </p>
            </div>

            <!-- CALCOLATORE INTERATTIVO -->
            <div class="calculator-box">
                <h3>üßÆ Calcolatore: Periodo ‚Üî Frequenza</h3>
                <p>
                    Converti rapidamente tra periodo (T) e frequenza (f). Formula: f = 1/T
                </p>

                <div class="calculator-dual responsive-grid">
                    <div>
                        <h4>Da Frequenza a Periodo</h4>
                        <label>Frequenza
                            (Hz):</label>
                        <input type="number" id="calc2_freq" value="100" min="0.001" step="0.001"
                            oninput="calcFreqToPeriod()">
                        <div>
                            <strong>Periodo (T):</strong> <span id="calc2_period_result">0.01 s</span><br>
                            <span>= <span id="calc2_period_ms"></span> ms</span>
                        </div>
                    </div>

                    <div>
                        <h4>Da Periodo a Frequenza</h4>
                        <label>Periodo
                            (secondi):</label>
                        <input type="number" id="calc2_period" value="0.01" min="0.000001" step="0.000001"
                            oninput="calcPeriodToFreq()">
                        <div>
                            <strong>Frequenza (f):</strong> <span id="calc2_freq_result">100 Hz</span><br>
                            <span>= <span id="calc2_freq_khz"></span> kHz</span>
                        </div>
                    </div>
                </div>

                <div>
                    <strong>üí° Esempi comuni:</strong><br>
                    ‚Ä¢ Rete elettrica: 50 Hz ‚Üí T = 20 ms<br>
                    ‚Ä¢ La nota DO centrale: 261.63 Hz ‚Üí T ‚âà 3.82 ms<br>
                    ‚Ä¢ Segnale audio 1 kHz: T = 1 ms
                </div>
            </div>
        </div>
    </div>

    <div id="modal3" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('modal3')">&times;</span>
            <h2>üìê Le Formule della Trasformata di Fourier</h2>

            <p>
                La matematica dietro la Trasformata di Fourier pu√≤ essere spiegata a diversi livelli di complessit√†.
                Scegli la spiegazione pi√π adatta al tuo percorso:
            </p>

            <div class="modal-tabs">
                <button class="modal-tab active" onclick="switchTab('tab-accessible')">Approccio Discreto (3¬∞
                    anno)</button>
                <button class="modal-tab" onclick="switchTab('tab-rigorous')">Approccio Continuo (4¬∞-5¬∞ anno)</button>
            </div>

            <div id="tab-accessible" class="tab-content active">
                <h3>Spiegazione Accessibile: Serie e DFT</h3>

                <p class="list-formatted">
                    Iniziamo con un concetto intuitivo: <strong>se un segnale si ripete nel tempo (√®
                        periodico)</strong>,
                    possiamo pensarlo come la <strong>somma di tante sinusoidi</strong>. Questa idea si chiama
                    <strong>Serie di Fourier</strong>.
                </p>

                <div class="application-box">
                    <h4>Serie di Fourier (Segnali Periodici)</h4>
                    <p>Un segnale periodico x(t) pu√≤ essere scritto come:</p>
                    <div class="formula">
                        x(t) = A‚ÇÄ + A‚ÇÅ¬∑sin(2œÄf‚ÇÅt + œÜ‚ÇÅ) + A‚ÇÇ¬∑sin(2œÄf‚ÇÇt + œÜ‚ÇÇ) + A‚ÇÉ¬∑sin(2œÄf‚ÇÉt + œÜ‚ÇÉ) + ...
                    </div>
                    <p>Dove:</p>
                    <ul>
                        <li><strong>A‚ÇÄ, A‚ÇÅ, A‚ÇÇ, A‚ÇÉ...</strong> sono le ampiezze delle varie componenti</li>
                        <li><strong>f‚ÇÅ, f‚ÇÇ, f‚ÇÉ...</strong> sono le frequenze (f‚ÇÇ = 2√óf‚ÇÅ, f‚ÇÉ = 3√óf‚ÇÅ...)</li>
                        <li><strong>œÜ‚ÇÅ, œÜ‚ÇÇ, œÜ‚ÇÉ...</strong> sono le fasi (spostamenti temporali)</li>
                    </ul>
                    <p>
                        üí° Il simbolo Œ£ (sigma maiuscolo) indica una somma: stiamo "sommando" tante sinusoidi!
                    </p>
                </div>

                <h4>DFT - Discrete Fourier Transform (Il Metodo del Computer)</h4>
                <p>
                    Quando lavoriamo con dati digitali (campioni presi a intervalli regolari, come fa un computer),
                    usiamo la <strong>DFT - Trasformata Discreta di Fourier</strong>. La formula √®:
                </p>

                <div class="formula">
                    X<sub>k</sub> = Œ£ (n=0 fino a N-1) x<sub>n</sub> ¬∑ e<sup>-i¬∑2œÄkn/N</sup>
                </div>

                <p>Sembra complicata, ma vediamo cosa significa:</p>
                <ul>
                    <li><strong>x<sub>n</sub></strong> sono i nostri campioni del segnale (es. 512 misure di tensione)
                    </li>
                    <li><strong>k</strong> √® l'indice della frequenza che stiamo cercando (k=0 √® la continua, k=1 √® la
                        fondamentale, k=2 la seconda armonica...)</li>
                    <li><strong>N</strong> √® il numero totale di campioni</li>
                    <li><strong>X<sub>k</sub></strong> √® il risultato: ci dice "quanto" della frequenza k-esima c'√® nel
                        segnale</li>
                </ul>

                <h4>Il Trucco di e<sup>-i¬∑Œ∏</sup> (per i Curiosi)</h4>
                <div>
                    <p>
                        Il simbolo <strong>e<sup>-i¬∑Œ∏</sup></strong> spaventa, ma √® solo un modo compatto di scrivere:
                    </p>
                    <div class="formula">
                        e<sup>-i¬∑Œ∏</sup> = cos(Œ∏) - i¬∑sin(Œ∏)
                    </div>
                    <p>
                        Dove <strong>i</strong> √® l'unit√† immaginaria (i¬≤ = -1). √à un "trucco" matematico per lavorare
                        contemporaneamente
                        con coseno e seno, che ci permette di trovare sia l'<strong>ampiezza</strong> che la
                        <strong>fase</strong>
                        di ogni frequenza in un colpo solo!
                    </p>
                    <p>
                        In pratica, stiamo <strong>moltiplicando</strong> il nostro segnale per varie sinusoidi (a
                        frequenze diverse)
                        e <strong>sommando</strong> i risultati. Se il segnale contiene quella frequenza, la somma sar√†
                        grande;
                        se non la contiene, la somma sar√† quasi zero. Semplice!
                    </p>
                </div>

                <h4>Riassunto Visivo</h4>
                <div>
                    <p>Il processo in 3 passi:</p>
                    <ol>
                        <li><strong>Campionamento:</strong> Misuro il segnale N volte (es. 1024 valori) ‚Üí ottengo x‚ÇÄ,
                            x‚ÇÅ, x‚ÇÇ... x‚ÇÅ‚ÇÄ‚ÇÇ‚ÇÉ</li>
                        <li><strong>DFT:</strong> Per ogni frequenza k, moltiplico i campioni per e<sup>-i¬∑2œÄkn/N</sup>
                            e sommo</li>
                        <li><strong>Risultato:</strong> Ottengo X‚ÇÄ, X‚ÇÅ, X‚ÇÇ... X‚ÇÅ‚ÇÄ‚ÇÇ‚ÇÉ ‚Üí lo spettro! Ogni X<sub>k</sub> mi
                            dice quanto √® presente quella frequenza</li>
                    </ol>
                </div>
            </div>

            <div id="tab-rigorous" class="tab-content">
                <h3>Spiegazione Rigorosa: La Trasformata Continua</h3>

                <p class="list-formatted">
                    Mentre la Serie di Fourier funziona per segnali <strong>periodici</strong> (che si ripetono),
                    la <strong>Trasformata di Fourier</strong> generalizza il concetto a <strong>qualsiasi
                        segnale</strong>,
                    anche quelli che durano un tempo finito o infinito ma non si ripetono.
                </p>

                <div>
                    <h4>Dal Discreto al Continuo</h4>
                    <p>
                        Nella DFT sommavamo (Œ£) un numero finito di campioni. Nella Trasformata continua,
                        la somma diventa una <strong>"somma infinita e continua"</strong>, cio√® un
                        <strong>integrale</strong> (‚à´).
                        Invece di frequenze discrete (f‚ÇÅ, 2f‚ÇÅ, 3f‚ÇÅ...), consideriamo <strong>tutte le frequenze
                            possibili</strong>
                        in modo continuo.
                    </p>
                </div>

                <h4>Trasformata di Fourier (FT)</h4>
                <p>
                    Dato un segnale nel tempo x(t), la sua Trasformata di Fourier X(f) √® definita come:
                </p>
                <div class="formula">
                    X(f) = ‚à´<sub>-‚àû</sub><sup>+‚àû</sup> x(t) ¬∑ e<sup>-i¬∑2œÄft</sup> dt
                </div>
                <p>Dove:</p>
                <ul>
                    <li><strong>x(t)</strong> √® il segnale nel dominio del tempo (funzione continua)</li>
                    <li><strong>f</strong> √® la frequenza (variabile continua, in Hz)</li>
                    <li><strong>X(f)</strong> √® lo spettro in frequenza (funzione complessa che descrive ampiezza e fase
                        per ogni f)</li>
                    <li><strong>e<sup>-i¬∑2œÄft</sup></strong> √® la funzione "sonda" (sinusoide complessa alla frequenza
                        f)</li>
                    <li><strong>‚à´ dt</strong> indica l'integrale rispetto al tempo, da -‚àû a +‚àû</li>
                </ul>

                <div>
                    <p>Interpretazione Fisica:</p>
                    <p>
                        L'integrale "confronta" il segnale x(t) con una sinusoide pura alla frequenza f.
                        Se il segnale contiene quella frequenza, il prodotto x(t)¬∑e<sup>-i¬∑2œÄft</sup> sar√† coerente
                        e l'integrale dar√† un valore grande. Se quella frequenza non c'√®, le oscillazioni si cancellano
                        e l'integrale tende a zero.
                    </p>
                </div>

                <h4>Trasformata Inversa di Fourier (IFT)</h4>
                <p>
                    Possiamo sempre tornare indietro: dato lo spettro X(f), ricostruiamo il segnale originale x(t):
                </p>
                <div class="formula">
                    x(t) = ‚à´<sub>-‚àû</sub><sup>+‚àû</sup> X(f) ¬∑ e<sup>+i¬∑2œÄft</sup> df
                </div>
                <p>
                    Nota il cambio di segno nell'esponente (+i invece di -i) e l'integrazione su df invece di dt.
                    Questa formula ci dice che il segnale x(t) √® la <strong>somma (integrale) di infinite
                        sinusoidi</strong>
                    e<sup>+i¬∑2œÄft</sup>, ciascuna pesata dal coefficiente X(f).
                </p>

                <h4>Propriet√† Fondamentali</h4>
                <div>
                    <p><strong>Linearit√†:</strong> FT{a¬∑x‚ÇÅ(t) + b¬∑x‚ÇÇ(t)} = a¬∑X‚ÇÅ(f) +
                        b¬∑X‚ÇÇ(f)</p>
                    <p><strong>Traslazione Temporale:</strong> Se x(t) ‚Üí X(f), allora
                        x(t-t‚ÇÄ) ‚Üí X(f)¬∑e<sup>-i¬∑2œÄft‚ÇÄ</sup></p>
                    <p><strong>Traslazione in Frequenza:</strong> Se x(t) ‚Üí X(f), allora
                        x(t)¬∑e<sup>i¬∑2œÄf‚ÇÄt</sup> ‚Üí X(f-f‚ÇÄ)</p>
                    <p><strong>Scaling:</strong> Se x(t) ‚Üí X(f), allora x(at) ‚Üí
                        (1/|a|)¬∑X(f/a)</p>
                    <p><strong>Convoluzione:</strong> FT{x‚ÇÅ(t) * x‚ÇÇ(t)} = X‚ÇÅ(f)¬∑X‚ÇÇ(f) (il prodotto di convoluzione nel
                        tempo diventa prodotto in frequenza!)</p>
                </div>

                <h4>Condizioni di Esistenza</h4>
                <p>
                    Affinch√© la Trasformata esista, il segnale x(t) deve essere <strong>assolutamente
                        integrabile</strong>:
                </p>
                <div class="formula">
                    ‚à´<sub>-‚àû</sub><sup>+‚àû</sup> |x(t)| dt &lt; ‚àû
                </div>
                <p>
                    In pratica, significa che il segnale non pu√≤ avere energia infinita. Molti segnali fisici reali
                    (impulsi, decadimenti esponenziali, segnali a durata finita) soddisfano questa condizione.
                </p>

                <div>
                    <p>
                        üéì Collegamento con la DFT
                    </p>
                    <p>
                        La DFT che usiamo al computer √® una <strong>approssimazione discreta</strong> della Trasformata
                        continua.
                        Quando campioniamo un segnale a intervalli regolari Œît e ne prendiamo N campioni,
                        la DFT calcola X(f) solo per N frequenze discrete e approssima l'integrale con una sommatoria.
                        Con N grande e Œît piccolo, la DFT converge alla FT teorica.
                    </p>
                </div>

                <!-- CALCOLATORE INTERATTIVO -->
                <div class="calculator-box">
                    <h3>üßÆ Calcolatore: Componente Sinusoidale</h3>
                    <p>
                        Calcola il valore di una componente sinusoidale in un dato istante di tempo.
                        Formula: y = A¬∑sin(2œÄft + œÜ)
                    </p>

                    <div class="calculator-grid responsive-grid">
                        <div>
                            <label>Ampiezza
                                (A):</label>
                            <input type="number" id="calc3_amp" value="1" step="0.1">
                        </div>
                        <div>
                            <label>Frequenza
                                (Hz):</label>
                            <input type="number" id="calc3_freq" value="50" min="0.1" step="0.1">
                        </div>
                        <div>
                            <label>Fase
                                (gradi):</label>
                            <input type="number" id="calc3_phase" value="0" step="1">
                        </div>
                        <div>
                            <label>Tempo
                                (secondi):</label>
                            <input type="number" id="calc3_time" value="0" step="0.001">
                        </div>
                    </div>

                    <button onclick="calculateSineWave()" class="btn-primary">
                        Calcola Valore
                    </button>

                    <div id="calc3_result">
                        <h4>üìä Risultati:</h4>
                        <div>
                            <p><strong>Formula espansa:</strong></p>
                            <div id="calc3_formula">
                            </div>
                        </div>
                        <div>
                            <p><strong>Valore calcolato:</strong></p>
                            <div id="calc3_value"></div>
                        </div>
                        <div>
                            <strong>üí° Info:</strong>
                            <div id="calc3_info"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- MODALE POTENZA DI 2 -->
    <div id="modalPowerOf2" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('modalPowerOf2')">&times;</span>
            <h2>üî¢ Perch√© usare Potenze di 2 per il numero di campioni?</h2>

            <h3>La FFT (Fast Fourier Transform)</h3>
            <p class="list-formatted">
                In pratica, quasi tutti i software (incluso questo laboratorio) utilizzano un algoritmo chiamato
                <strong>FFT (Fast Fourier Transform)</strong> invece della DFT classica. La FFT √® un algoritmo
                "furbo" che calcola la stessa trasformata, ma in modo molto pi√π veloce.
            </p>

            <div class="application-box">
                <p class="btn-bottom-spaced"><strong>Velocit√† della FFT vs DFT classica:</strong></p>
                <ul>
                    <li>DFT classica con N campioni: richiede circa <strong>N¬≤</strong> operazioni</li>
                    <li>FFT con N campioni (N = potenza di 2): richiede circa <strong>N¬∑log‚ÇÇ(N)</strong> operazioni</li>
                </ul>
                <p>
                    üìä Esempio pratico: con 1024 campioni (2¬π‚Å∞):
                </p>
                <ul>
                    <li>DFT classica: ~1.048.576 operazioni</li>
                    <li>FFT: ~10.240 operazioni (oltre 100 volte pi√π veloce!)</li>
                </ul>
            </div>

            <h3>Cosa succede se N non √® una potenza di 2?</h3>
            <div>
                <p>
                    <strong>La FFT funziona comunque</strong>, ma pu√≤ essere significativamente pi√π lenta. Molte
                    implementazioni moderne della FFT (incluse quelle usate da librerie come NumPy o MATLAB)
                    gestiscono numeri di campioni che non sono potenze di 2, ma:
                </p>
                <ul>
                    <li>Se N √® una potenza di 2 ‚Üí <strong>FFT standard (velocissima)</strong></li>
                    <li>Se N √® divisibile per piccoli fattori primi (2, 3, 5) ‚Üí <strong>FFT "mista" (abbastanza
                            veloce)</strong></li>
                    <li>Se N √® un numero primo grande ‚Üí <strong>FFT ricade nella DFT classica (lenta)</strong></li>
                </ul>
            </div>

            <h3>Potenze di 2 comuni</h3>
            <div class="formula">
                64 (2‚Å∂) | 128 (2‚Å∑) | 256 (2‚Å∏) | 512 (2‚Åπ) | 1024 (2¬π‚Å∞) | 2048 (2¬π¬π) | 4096 (2¬π¬≤) | 8192 (2¬π¬≥)
            </div>

            <h3>Raccomandazioni pratiche</h3>
            <div>
                <p>
                    <strong>‚úì Quando possibile, usa sempre potenze di 2</strong> per ottenere le migliori
                    prestazioni.<br><br>
                    <strong>‚úì Se il campionamento sincrono non produce una potenza di 2</strong>, valuta se:
                </p>
                <ul>
                    <li>Il leakage spettrale √® accettabile per il tuo scopo (spesso lo √® in applicazioni didattiche)
                    </li>
                    <li>Puoi arrotondare il numero di campioni alla potenza di 2 pi√π vicina e accettare un leggero
                        errore</li>
                    <li>√à necessario usare finestre (Hanning, Hamming, Blackman) per ridurre il leakage</li>
                </ul>
            </div>

            <h3>Nel nostro laboratorio</h3>
            <p class="list-formatted">
                Quando il <strong>campionamento sincrono</strong> √® attivo, il sistema calcola automaticamente il numero
                di campioni per catturare un numero intero di periodi. Se questo numero non √® una potenza di 2,
                vedrai un avviso giallo che ti suggerisce la potenza di 2 pi√π vicina.
            </p>
            <p>
                üí° Puoi scegliere: privilegiare il campionamento sincrono (spettro pulito) o usare una potenza di 2
                (calcolo veloce). Spesso, per segnali didattici, la differenza √® trascurabile!
            </p>
        </div>
    </div>

    <!-- MODALE GUIDA CAMPIONAMENTO -->
    <div id="modalSamplingGuide" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('modalSamplingGuide')">&times;</span>
            <h2>üìä Guida al Campionamento Non Sincrono</h2>

            <p>
                Quando il <strong>campionamento sincrono</strong> √® disattivato, puoi variare indipendentemente
                la frequenza di campionamento e il numero di campioni. Questa guida ti aiuter√† a scegliere i
                parametri ottimali in base al tuo segnale.
            </p>

            <div class="modal-tabs">
                <button class="modal-tab active" onclick="switchTab('tab-freq-to-samples')">Da Frequenza a
                    Campioni</button>
                <button class="modal-tab" onclick="switchTab('tab-samples-to-freq')">Da Campioni a Frequenza</button>
                <button class="modal-tab" onclick="switchTab('tab-windowing')">Gestire il Windowing</button>
            </div>

            <div id="tab-freq-to-samples" class="tab-content active">
                <h3>Come calcolare il numero di campioni data la frequenza</h3>

                <p>
                    <strong>Scenario:</strong> Hai un segnale a frequenza <em>f</em> Hz e stai usando una frequenza
                    di campionamento <em>F<sub>s</sub></em> Hz. Vuoi decidere quanti campioni <em>N</em> acquisire.
                </p>

                <div class="formula">
                    N = (Numero di periodi desiderato) √ó (F<sub>s</sub> / f)
                </div>

                <h4>Esempio pratico</h4>
                <div>
                    <p><strong>Dati:</strong></p>
                    <ul>
                        <li>Frequenza segnale: f = 100 Hz</li>
                        <li>Frequenza campionamento: F<sub>s</sub> = 8000 Hz</li>
                        <li>Voglio catturare 10 periodi completi</li>
                    </ul>
                    <p><strong>Calcolo:</strong></p>
                    <div class="formula">
                        Campioni per periodo = 8000 / 100 = 80<br>
                        N = 10 √ó 80 = 800 campioni
                    </div>
                    <p>
                        ‚úì Con 800 campioni catturo esattamente 10 periodi ‚Üí nessun windowing!
                    </p>
                </div>

                <h4>E se voglio una potenza di 2?</h4>
                <div>
                    <p>
                        Nell'esempio sopra, 800 non √® una potenza di 2. Le potenze di 2 pi√π vicine sono:
                    </p>
                    <ul>
                        <li>512 (2‚Åπ) = 6.4 periodi ‚Üí leggero windowing</li>
                        <li>1024 (2¬π‚Å∞) = 12.8 periodi ‚Üí leggero windowing</li>
                    </ul>
                    <p>
                        üí° Strategia: usa 1024 campioni e accetta un piccolo windowing, oppure scegli una frequenza
                        di segnale che renda 512 o 1024 sincroni (es. f = 8000/512 √ó intero).
                    </p>
                </div>

                <!-- CALCOLATORE INTERATTIVO -->
                <div class="calculator-box">
                    <h3>üßÆ Calcolatore: Campioni Ottimali</h3>
                    <p>
                        Calcola il numero ottimale di campioni per campionamento sincrono.
                    </p>

                    <div class="calculator-grid responsive-grid">
                        <div>
                            <label>Frequenza
                                Segnale (Hz):</label>
                            <input type="number" id="calc4_freq" value="100" min="0.1" step="0.1">
                        </div>
                        <div>
                            <label>Freq.
                                Campionamento (Hz):</label>
                            <input type="number" id="calc4_fs" value="8000" min="100" step="100">
                        </div>
                        <div>
                            <label>Periodi
                                Desiderati:</label>
                            <input type="number" id="calc4_periods" value="10" min="1" step="1">
                        </div>
                    </div>

                    <button onclick="calculateOptimalSamples()" class="btn-primary">
                        Calcola Campioni Ottimali
                    </button>

                    <div id="calc4_result">
                        <h4>üìä Risultati:</h4>
                        <div>
                            <p><strong>Campioni per periodo:</strong> <span id="calc4_spp"></span></p>
                            <p><strong>Campioni totali (esatti):</strong> <span id="calc4_exact"></span></p>
                            <p><strong>Potenza di 2 pi√π vicina:</strong> <span id="calc4_pow2"></span></p>
                            <p><strong>Numero di periodi con potenza di 2:</strong> <span
                                    id="calc4_periods_pow2"></span></p>
                        </div>
                        <div id="calc4_warning">
                        </div>
                        <div>
                            <strong>üí° Raccomandazione:</strong> <span id="calc4_recommendation"></span>
                        </div>
                    </div>
                </div>
            </div>

            <div id="tab-samples-to-freq" class="tab-content">
                <h3>Come calcolare la frequenza di campionamento dato il numero di campioni</h3>

                <p>
                    <strong>Scenario:</strong> Vuoi usare un numero specifico di campioni <em>N</em> (magari una
                    potenza di 2), e hai un segnale a frequenza <em>f</em> Hz. Come scegli <em>F<sub>s</sub></em>?
                </p>

                <div class="formula">
                    F<sub>s</sub> = (N / Numero di periodi desiderato) √ó f
                </div>

                <h4>Esempio pratico</h4>
                <div>
                    <p><strong>Dati:</strong></p>
                    <ul>
                        <li>Frequenza segnale: f = 100 Hz</li>
                        <li>Voglio usare N = 1024 campioni (potenza di 2)</li>
                        <li>Voglio catturare 8 periodi completi</li>
                    </ul>
                    <p><strong>Calcolo:</strong></p>
                    <div class="formula">
                        F<sub>s</sub> = (1024 / 8) √ó 100 = 128 √ó 100 = 12800 Hz
                    </div>
                    <p>
                        ‚úì Con F<sub>s</sub> = 12800 Hz e N = 1024, catturo esattamente 8 periodi di 100 Hz!
                    </p>
                </div>

                <h4>Vincolo del Teorema di Nyquist</h4>
                <div>
                    <p>
                        <strong>‚ö† Attenzione:</strong> La frequenza di campionamento <em>F<sub>s</sub></em> deve
                        sempre essere almeno il doppio della frequenza massima del segnale:
                    </p>
                    <div class="formula">
                        F<sub>s</sub> ‚â• 2 √ó f<sub>max</sub>
                    </div>
                    <p>
                        Se il tuo segnale contiene armoniche (es. onda quadra), considera la frequenza dell'armonica
                        pi√π alta che vuoi preservare, non solo la fondamentale!
                    </p>
                </div>
            </div>

            <div id="tab-windowing" class="tab-content">
                <h3>Comprendere e gestire il Windowing</h3>

                <p>
                    Il <strong>windowing</strong> (o leakage spettrale) si verifica quando il numero di campioni
                    non cattura un numero intero di periodi del segnale. √à come "tagliare" il segnale a met√† di
                    un'oscillazione: la DFT "vede" una discontinuit√† e interpreta questo come la presenza di molte
                    frequenze diverse.
                </p>

                <h4>Visualizzazione del problema</h4>
                <div>
                    <p><strong>Segnale ben campionato (sincrono):</strong></p>
                    <pre>
___/‚Äæ‚Äæ‚Äæ\___/‚Äæ‚Äæ‚Äæ\___/‚Äæ‚Äæ‚Äæ\___/‚Äæ‚Äæ‚Äæ\___
   ‚Üë                           ‚Üë
Inizio                       Fine
(il segnale si "richiude" perfettamente)
                    </pre>
                    <p>
                        ‚úì Spettro: un singolo picco netto alla frequenza corretta
                    </p>

                    <p><strong>Segnale mal campionato (non sincrono):</strong></p>
                    <pre>
___/‚Äæ‚Äæ‚Äæ\___/‚Äæ‚Äæ‚Äæ\___/‚Äæ‚Äæ
   ‚Üë               ‚Üë
Inizio          Fine
(il segnale "salta" tra fine e inizio)
                    </pre>
                    <p>
                        ‚ö† Spettro: il picco si "allarga" con lobi laterali (leakage)
                    </p>
                </div>

                <h4>Soluzioni al problema del Windowing</h4>
                <div>
                    <p><strong>1. Campionamento Sincrono (ideale)</strong></p>
                    <p>
                        Calcola N in modo che catturi esattamente un numero intero di periodi. Usa il calcolatore
                        nelle tab precedenti!
                    </p>

                    <p><strong>2. Usa Finestre (windowing
                            functions)</strong></p>
                    <p>
                        Moltiplica il segnale per una "finestra" (es. Hanning, Hamming, Blackman) che attenua
                        gradualmente il segnale all'inizio e alla fine, riducendo la discontinuit√†. Questo riduce
                        il leakage ma "allarga" leggermente i picchi.
                    </p>

                    <p><strong>3. Zero-padding</strong></p>
                    <p>
                        Aggiungi zeri alla fine del segnale fino a raggiungere una potenza di 2. Questo migliora
                        la risoluzione in frequenza (pi√π punti nello spettro) ma non elimina il leakage se il segnale
                        originale non era sincrono.
                    </p>

                    <p><strong>4. Accetta un leggero
                            leakage</strong></p>
                    <p>
                        In molte applicazioni pratiche (soprattutto didattiche), un piccolo leakage √® tollerabile.
                        Se il numero di periodi √® "quasi" intero (es. 10.1 o 9.9), l'effetto sar√† minimo.
                    </p>
                </div>

                <h4>Calcolo rapido del numero di periodi</h4>
                <div class="formula">
                    Numero di periodi = (N √ó f) / F<sub>s</sub>
                </div>
                <p>
                    Dove: N = numero di campioni, f = frequenza del segnale, F<sub>s</sub> = frequenza di campionamento
                </p>
                <p>
                    üí° Se il risultato √® un numero intero (o molto vicino, es. ¬±0.05), non avrai windowing!
                </p>
            </div>
        </div>
    </div>

    <!-- MODALE CONFRONTO FINESTRE -->
    <div id="modalWindowComparison" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('modalWindowComparison')">&times;</span>
            <h2>ü™ü Confronto Funzioni di Finestra</h2>

            <p>
                Ogni funzione di finestra ha caratteristiche diverse in termini di attenuazione del leakage,
                larghezza del lobo principale e soppressione dei lobi laterali. Scegli la finestra in base alle tue
                esigenze.
            </p>

            <!-- Grafici di confronto -->
            <div>
                <h3>Forma delle Finestre nel Tempo</h3>
                <div id="windowShapeChart"></div>
            </div>

            <div>
                <h3>Risposta in Frequenza delle Finestre</h3>
                <div id="windowFreqChart"></div>
            </div>

            <!-- Tabella caratteristiche -->
            <div>
                <h3>Caratteristiche delle Finestre</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Finestra</th>
                            <th>Larghezza Lobo
                                Principale</th>
                            <th>Attenuazione Lobi
                                Laterali</th>
                            <th>Uso Tipico</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Rettangolare</strong></td>
                            <td>Minima (2 bin)</td>
                            <td>-13 dB</td>
                            <td>Segnali sincronizzati perfettamente</td>
                        </tr>
                        <tr>
                            <td><strong>Hanning</strong></td>
                            <td>Media (4 bin)</td>
                            <td>-31 dB</td>
                            <td>Uso generale, buon compromesso</td>
                        </tr>
                        <tr>
                            <td><strong>Hamming</strong></td>
                            <td>Media (4 bin)</td>
                            <td>-43 dB</td>
                            <td>Migliore soppressione lobi laterali</td>
                        </tr>
                        <tr>
                            <td><strong>Blackman</strong></td>
                            <td>Larga (6 bin)</td>
                            <td>-58 dB</td>
                            <td>Massima attenuazione lobi laterali</td>
                        </tr>
                        <tr>
                            <td><strong>Bartlett</strong></td>
                            <td>Media (4 bin)</td>
                            <td>-27 dB</td>
                            <td>Segnali transitori</td>
                        </tr>
                        <tr>
                            <td><strong>Kaiser (Œ≤=5)</strong></td>
                            <td>Regolabile</td>
                            <td>-50 dB</td>
                            <td>Controllo preciso, applicazioni
                                professionali</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div>
                <h4>üí° Come Scegliere la Finestra Giusta?</h4>
                <ul>
                    <li><strong>Hanning:</strong> La scelta pi√π comune per uso generale. Buon equilibrio tra risoluzione
                        e riduzione del leakage.</li>
                    <li><strong>Hamming:</strong> Migliore di Hanning se i lobi laterali sono un problema critico.</li>
                    <li><strong>Blackman:</strong> Usa quando devi minimizzare al massimo il leakage, anche a costo di
                        una minore risoluzione in frequenza.</li>
                    <li><strong>Bartlett:</strong> Buona per segnali transitori o con inizio/fine naturalmente
                        attenuati.</li>
                    <li><strong>Kaiser:</strong> Per applicazioni professionali dove serve controllo preciso del
                        compromesso risoluzione/leakage.</li>
                    <li><strong>Rettangolare:</strong> Solo se il tuo segnale √® perfettamente sincronizzato (numero
                        intero di periodi).</li>
                </ul>
            </div>

            <button onclick="closeModal('modalWindowComparison')">
                Chiudi
            </button>
        </div>
    </div>

    <!-- MODALE TEORIA DELLE FINESTRE -->
    <div id="modalWindowTheory" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('modalWindowTheory')">&times;</span>
            <h2>üìö Teoria delle Funzioni di Finestra</h2>

            <!-- Introduzione -->
            <div>
                <h3>üéØ Perch√© Servono le Finestre?</h3>
                <p class="list-formatted">
                    Quando applichiamo la Trasformata di Fourier (FFT) a un segnale finito, stiamo implicitamente
                    assumendo che
                    il segnale si ripeta all'infinito. Se il segnale non contiene un numero intero di periodi completi,
                    si creano <strong>discontinuit√† artificiali</strong> ai bordi della finestra di acquisizione.
                </p>
                <p>
                    Queste discontinuit√† generano il fenomeno del <strong>leakage
                        spettrale</strong>
                    (perdita o dispersione spettrale): l'energia di una singola frequenza si "disperde" su molte
                    frequenze
                    adiacenti nello spettro, creando lobi laterali indesiderati e rendendo difficile l'identificazione
                    precisa delle frequenze presenti nel segnale.
                </p>
            </div>

            <!-- Il Problema del Leakage -->
            <div>
                <h3>‚ö†Ô∏è Il Problema del Leakage Spettrale</h3>
                <p>
                    Immagina di voler analizzare un segnale sinusoidale a 100 Hz. Se la tua finestra di acquisizione
                    cattura esattamente 1, 2 o 3 cicli completi, la FFT mostrer√† un picco perfetto a 100 Hz.
                    Ma se catturi 2.3 cicli, il segnale viene "tagliato" a met√† di un'oscillazione.
                </p>
                <div>
                    <p>
                        <strong>Effetto:</strong> Invece di un singolo picco nitido a 100 Hz, vedrai un picco principale
                        con "code" che si estendono alle frequenze vicine (95 Hz, 105 Hz, ecc.). Questa dispersione
                        pu√≤ nascondere frequenze pi√π deboli presenti nel segnale!
                    </p>
                </div>
            </div>

            <!-- Come Funzionano le Finestre -->
            <div>
                <h3>üõ†Ô∏è Come Funzionano le Finestre?</h3>
                <p>
                    Le funzioni di finestra moltiplicano il segnale per una curva che vale:
                </p>
                <ul>
                    <li><strong>1 (o vicino a 1) al centro</strong> della finestra temporale</li>
                    <li><strong>0 (o vicino a 0) agli estremi</strong> della finestra temporale</li>
                </ul>
                <p>
                    In questo modo, il segnale viene "sfumato" gradualmente verso zero ai bordi, eliminando le
                    discontinuit√† artificiali. Il prezzo da pagare √® una <strong>riduzione della risoluzione in
                        frequenza</strong>:
                    il lobo principale diventa pi√π largo, rendendo pi√π difficile separare frequenze molto vicine.
                </p>
                <div>
                    <p>
                        <strong>üí° Trade-off fondamentale:</strong> Migliore soppressione del leakage = minore
                        risoluzione in frequenza.
                        Devi scegliere la finestra in base a cosa √® pi√π importante per la tua applicazione!
                    </p>
                </div>
            </div>

            <!-- Applicazioni nel Mondo Reale -->
            <div>
                <h3>üåç Applicazioni nel Mondo Reale</h3>

                <div>
                    <h4>üåä Applicazioni Marine e Oceanografiche</h4>
                    <ul>
                        <li><strong>Sonar e Acustica Subacquea:</strong> Analisi delle frequenze riflesse per rilevare
                            sottomarini, banchi di pesci o ostacoli sottomarini. Le finestre di Hamming o Blackman
                            riducono
                            i falsi echi causati dal leakage.</li>
                        <li><strong>Analisi delle Onde Marine:</strong> Studio dello spettro delle onde oceaniche per
                            prevedere tempeste e maree. La finestra di Hanning √® ideale per segnali quasi-periodici come
                            le onde.</li>
                        <li><strong>Monitoraggio Sismico Marino:</strong> Rilevamento di terremoti sottomarini e
                            tsunami.
                            Le finestre aiutano a distinguere le frequenze sismiche dai rumori di fondo dell'oceano.
                        </li>
                        <li><strong>Comunicazioni Subacquee:</strong> Trasmissione dati attraverso onde acustiche.
                            Il windowing migliora la demodulazione dei segnali in presenza di rumore e riflessioni
                            multiple.</li>
                    </ul>
                </div>

                <div>
                    <h4>üéµ Audio e Musica</h4>
                    <ul>
                        <li><strong>Equalizzatori e Processori Audio:</strong> Analisi in tempo reale dello spettro
                            per regolare bassi, medi e alti. La finestra di Hanning √® standard per questo scopo.</li>
                        <li><strong>Riconoscimento Vocale:</strong> Identificazione di fonemi e parole. Le finestre
                            brevi (20-30 ms) con Hamming permettono di catturare le variazioni rapide della voce.</li>
                        <li><strong>Compressione Audio (MP3, AAC):</strong> Gli algoritmi di compressione usano FFT
                            con finestre sovrapposte per identificare quali frequenze possono essere eliminate senza
                            compromettere la qualit√† percepita.</li>
                    </ul>
                </div>

                <div>
                    <h4>üì° Telecomunicazioni e Radar</h4>
                    <ul>
                        <li><strong>Radar Meteorologico:</strong> Rilevamento di precipitazioni e vento. Le finestre
                            riducono i lobi laterali che causerebbero falsi allarmi per echi deboli.</li>
                        <li><strong>Radar Aeronautico e Navale:</strong> Individuazione di aerei e navi. La finestra di
                            Kaiser permette di ottimizzare il trade-off tra rilevamento di bersagli deboli e risoluzione
                            angolare.</li>
                        <li><strong>Analisi dello Spettro RF:</strong> Monitoraggio delle frequenze radio per rilevare
                            interferenze e ottimizzare l'uso dello spettro elettromagnetico.</li>
                        <li><strong>Sistemi LTE/5G:</strong> Le reti cellulari usano OFDM (Orthogonal Frequency Division
                            Multiplexing) che richiede finestre per ridurre l'interferenza tra canali adiacenti.</li>
                    </ul>
                </div>

                <div>
                    <h4>üè• Biomedica e Diagnostica</h4>
                    <ul>
                        <li><strong>Elettrocardiogramma (ECG):</strong> Analisi delle frequenze del battito cardiaco
                            per rilevare aritmie. Le finestre aiutano a isolare i segnali cardiaci dal rumore muscolare.
                        </li>
                        <li><strong>Elettroencefalogramma (EEG):</strong> Studio delle onde cerebrali (delta, theta,
                            alpha, beta). La finestra di Hamming √® comunemente usata per analizzare l'attivit√† cerebrale
                            durante il sonno.</li>
                        <li><strong>Ultrasuoni Medici:</strong> Imaging ecografico per diagnosi. Il windowing migliora
                            la risoluzione delle immagini riducendo gli artefatti.</li>
                        <li><strong>Analisi della Vibrazione Vocale:</strong> Diagnosi di disturbi delle corde vocali
                            analizzando le frequenze della voce.</li>
                    </ul>
                </div>

                <div>
                    <h4>üè≠ Ingegneria e Manutenzione Predittiva</h4>
                    <ul>
                        <li><strong>Analisi delle Vibrazioni:</strong> Monitoraggio di motori, turbine e cuscinetti.
                            Le variazioni nello spettro di vibrazione indicano guasti imminenti (es. cuscinetti usurati
                            producono frequenze caratteristiche).</li>
                        <li><strong>Controllo Qualit√†:</strong> Test non distruttivi di materiali usando ultrasuoni.
                            Le finestre migliorano il rilevamento di micro-cricche.</li>
                        <li><strong>Turbine Eoliche:</strong> Analisi delle vibrazioni per ottimizzare le prestazioni
                            e prevenire rotture delle pale.</li>
                    </ul>
                </div>

                <div>
                    <h4 class="preset-title">üî¨ Ricerca Scientifica</h4>
                    <ul>
                        <li><strong>Astrofisica:</strong> Analisi della radiazione elettromagnetica da stelle e galassie
                            per determinarne composizione e movimento (effetto Doppler).</li>
                        <li><strong>Sismologia:</strong> Studio delle onde sismiche per comprendere la struttura interna
                            della Terra e prevedere terremoti.</li>
                        <li><strong>Fisica delle Particelle:</strong> Analisi dei segnali dai rivelatori per
                            identificare
                            particelle subatomiche.</li>
                    </ul>
                </div>
            </div>

            <!-- Guida alla Scelta -->
            <div>
                <h3>üéì Come Scegliere la Finestra Giusta</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Situazione</th>
                            <th>Finestra Consigliata
                            </th>
                            <th>Motivo</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Segnale perfettamente sincronizzato
                            </td>
                            <td><strong>Rettangolare</strong></td>
                            <td>Massima risoluzione senza leakage</td>
                        </tr>
                        <tr>
                            <td>Uso generale, non sai cosa aspettarti
                            </td>
                            <td><strong>Hanning</strong></td>
                            <td>Miglior compromesso universale</td>
                        </tr>
                        <tr>
                            <td>Devi rilevare segnali deboli vicino a
                                segnali forti</td>
                            <td><strong>Blackman</strong></td>
                            <td>Massima soppressione lobi laterali
                            </td>
                        </tr>
                        <tr>
                            <td>Audio, voce, musica</td>
                            <td><strong>Hanning o Hamming</strong>
                            </td>
                            <td>Standard industriale per audio</td>
                        </tr>
                        <tr>
                            <td>Radar, sonar, telecomunicazioni</td>
                            <td><strong>Hamming o Kaiser</strong></td>
                            <td>Eccellente reiezione interferenze</td>
                        </tr>
                        <tr>
                            <td>Segnali transitori (impulsi)</td>
                            <td><strong>Bartlett</strong></td>
                            <td>Buona per segnali che
                                iniziano/finiscono a zero</td>
                        </tr>
                        <tr>
                            <td>Serve controllo preciso del trade-off
                            </td>
                            <td><strong>Kaiser (Œ≤ regolabile)</strong>
                            </td>
                            <td>Permette di ottimizzare per
                                l'applicazione specifica</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <!-- Formula Matematica (esempio Hanning) -->
            <div>
                <h3>üìê Esempio: Finestra di Hanning</h3>
                <p>
                    La finestra di Hanning √® definita matematicamente come:
                </p>
                <p>
                    w[n] = 0.5 √ó (1 - cos(2œÄ √ó n / (N-1)))
                </p>
                <p>
                    Dove <strong>N</strong> √® il numero totale di campioni e <strong>n</strong> va da 0 a N-1.
                </p>
                <p>
                    Questa funzione vale 0 agli estremi (n=0 e n=N-1) e raggiunge il massimo (1) al centro (n=N/2),
                    creando una curva a forma di campana che "sfuma" dolcemente il segnale verso i bordi.
                </p>
            </div>

            <!-- Conclusione -->
            <div>
                <h3>‚úÖ In Sintesi</h3>
                <ul>
                    <li>Le finestre risolvono il problema del <strong>leakage spettrale</strong> causato dalla natura
                        finita dei dati reali</li>
                    <li>Ogni finestra rappresenta un <strong>compromesso</strong> tra risoluzione in frequenza e
                        soppressione del leakage</li>
                    <li>La scelta dipende dall'<strong>applicazione specifica</strong>: cosa vuoi misurare e quali
                        errori puoi tollerare</li>
                    <li>Nel dubbio, <strong>Hanning √® la scelta pi√π sicura</strong> per iniziare</li>
                    <li>Le applicazioni pratiche spaziano da <strong>marine/oceanografiche</strong> a
                        <strong>biomedicali</strong>,
                        da <strong>audio</strong> a <strong>radar/telecomunicazioni</strong>
                    </li>
                </ul>
            </div>

            <button onclick="closeModal('modalWindowTheory')">
                Ho Capito!
            </button>
        </div>
    </div>

    <!-- MODALE CONFRONTO CAMPIONAMENTO SINCRONO -->
    <div id="modalSyncComparison" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('modalSyncComparison')">&times;</span>
            <h2>üîç Confronto: Campionamento Sincrono vs Non Sincrono</h2>

            <p>
                Questo confronto mostra la differenza tra un segnale campionato con un <strong>numero intero di
                    periodi</strong> (campionamento sincrono, senza leakage) e uno con un <strong>numero non intero di
                    periodi</strong> (campionamento non sincrono, con leakage spettrale).
            </p>

            <!-- Pannello di controllo -->
            <div>
                <h3>‚öôÔ∏è Configura il Confronto</h3>
                <div>
                    <div>
                        <label>Frequenza Segnale
                            (Hz):</label>
                        <input type="number" id="compFreq" value="100" min="10" max="1000" step="10">
                    </div>
                    <div>
                        <label>Frequenza di Campionamento
                            (Hz):</label>
                        <input type="number" id="compSampleRate" value="8000" min="1000" max="48000" step="1000">
                    </div>
                    <div>
                        <label>Numero Campioni
                            Target:</label>
                        <input type="number" id="compSamples" value="1024" min="256" max="4096" step="256">
                    </div>
                </div>
                <button onclick="generateComparison()">
                    üîÑ Genera Confronto
                </button>
            </div>

            <!-- Info campionamento -->
            <div id="comparisonInfo">
                <h4>üìä Informazioni Campionamento</h4>
                <div class="responsive-grid">
                    <div>
                        <strong>Con Campionamento Sincrono:</strong>
                        <ul>
                            <li>Campioni: <span id="syncSamplesInfo"></span></li>
                            <li>Periodi catturati: <span id="syncPeriodsInfo"></span></li>
                            <li>Durata: <span id="syncDurationInfo"></span></li>
                        </ul>
                    </div>
                    <div>
                        <strong>Senza Campionamento Sincrono:</strong>
                        <ul>
                            <li>Campioni: <span id="nonsyncSamplesInfo"></span></li>
                            <li>Periodi catturati: <span id="nonsyncPeriodsInfo"></span></li>
                            <li>Durata: <span id="nonsyncDurationInfo"></span></li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Grafici confronto -->
            <div class="responsive-grid">
                <!-- Segnali nel tempo -->
                <div>
                    <h3>‚úÖ Campionamento Sincrono</h3>
                    <p>
                        Numero intero di periodi ‚Üí Nessun leakage
                    </p>
                    <div id="syncTimeChart"></div>
                </div>
                <div>
                    <h3>‚ö†Ô∏è Campionamento Non Sincrono</h3>
                    <p>
                        Numero non intero di periodi ‚Üí Leakage presente
                    </p>
                    <div id="nonsyncTimeChart"></div>
                </div>
            </div>

            <div class="responsive-grid">
                <!-- Spettri in frequenza -->
                <div>
                    <h3>üìä Spettro Sincrono</h3>
                    <p>
                        Picco pulito, nessun lobo laterale
                    </p>
                    <div id="syncFreqChart"></div>
                </div>
                <div>
                    <h3>üìä Spettro Non Sincrono</h3>
                    <p>
                        Picco con lobi laterali (leakage)
                    </p>
                    <div id="nonsyncFreqChart"></div>
                </div>
            </div>

            <!-- Analisi differenze -->
            <div>
                <h3>üìà Analisi delle Differenze</h3>
                <div id="comparisonAnalysis">
                    <p><em>Genera un confronto per vedere l'analisi dettagliata...</em></p>
                </div>
            </div>

            <!-- Spiegazione -->
            <div>
                <h3>üí° Cosa Osservare</h3>
                <ul>
                    <li><strong>Nel dominio del tempo:</strong> Il campionamento sincrono cattura cicli completi del
                        segnale,
                        mentre il non sincrono termina a met√† di un ciclo, creando una discontinuit√†.</li>
                    <li><strong>Nel dominio della frequenza (sincrono):</strong> Vedrai un singolo picco pulito alla
                        frequenza del segnale, senza "code" laterali.</li>
                    <li><strong>Nel dominio della frequenza (non sincrono):</strong> Il picco principale avr√† dei lobi
                        laterali che si estendono alle frequenze vicine - questo √® il <strong>leakage
                            spettrale</strong>.</li>
                    <li><strong>Impatto pratico:</strong> Il leakage pu√≤ mascherare frequenze deboli vicino a frequenze
                        forti, rendendo difficile l'analisi spettrale precisa.</li>
                    <li><strong>Soluzione:</strong> Usa il campionamento sincrono quando possibile, oppure applica una
                        funzione di finestra (windowing) per ridurre il leakage.</li>
                </ul>
            </div>

            <button onclick="closeModal('modalSyncComparison')">
                Chiudi
            </button>
        </div>
    </div>

    <!-- Modale Esercizio 5 -->
    <div id="modalExercise5" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('modalExercise5')">&times;</span>
            <h2>ü™ü Esercizio Finestre</h2>

            <div class="exercise-objective">
                <strong>üìã Configurazione Applicata:</strong>
                <p>Ho configurato un segnale a 100 Hz con campionamento NON sincrono (950 campioni).</p>
            </div>

            <h3>üîç Cosa Osservare</h3>
            <p class="list-formatted">
                Vedrai del <strong>leakage spettrale</strong> nel grafico della frequenza. Questo accade perch√© il
                numero di campioni non √® perfettamente sincronizzato con la frequenza del segnale.
            </p>

            <h3>üéØ Il Tuo Compito</h3>
            <p class="list-formatted">
                Prova diverse finestre nel pannello <strong>"Funzioni di Finestra"</strong> e osserva come cambiano
                lo spettro! Ogni finestra ha caratteristiche diverse:
            </p>

            <ul class="list-formatted">
                <li><strong>Rettangolare:</strong> Nessun filtraggio, massimo leakage</li>
                <li><strong>Hanning:</strong> Buon compromesso tra risoluzione e leakage</li>
                <li><strong>Hamming:</strong> Ottimo per ridurre i lobi laterali</li>
                <li><strong>Blackman:</strong> Minimo leakage, ma riduce la risoluzione</li>
            </ul>

            <div class="application-box">
                <p class="application-item">
                    <strong>üí° Suggerimento:</strong> Usa il pulsante
                    <strong>"üìä Confronta Tutte le Finestre"</strong> per vedere le differenze
                    affiancate e capire quale finestra √® migliore per il tuo caso d'uso!
                </p>
            </div>

            <button onclick="closeModal('modalExercise5')" class="btn-primary">
                Ho Capito, Iniziamo! üöÄ
            </button>
        </div>
    </div>

    <!-- Modale Esercizio 4 -->
    <div id="modalExercise4" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('modalExercise4')">&times;</span>
            <h2>üìê Esercizio Windowing</h2>

            <div class="exercise-objective">
                <strong>üìã Configurazione Applicata:</strong>
                <p>Ho configurato un segnale sinusoidale a 100 Hz con campionamento sincrono attivo.</p>
            </div>

            <h3>üîç Osserva lo Spettro Pulito</h3>
            <p class="list-formatted">
                Con il <strong>campionamento sincrono attivo</strong>, vedrai uno spettro molto pulito con un picco
                preciso alla frequenza del segnale (100 Hz) e senza lobi laterali significativi.
            </p>

            <h3>üéØ Il Tuo Compito</h3>
            <p class="list-formatted">
                Ora sperimenta con questi passaggi per vedere il <strong>leakage spettrale</strong>:
            </p>

            <ol class="list-formatted">
                <li><strong>Disattiva il campionamento sincrono</strong> usando il checkbox nel pannello "Generatore di
                    Segnali"</li>
                <li><strong>Modifica il numero di campioni</strong> (ad esempio: 950, 1000, 1100) per creare
                    campionamenti non sincronizzati</li>
                <li><strong>Osserva come cambia lo spettro</strong> - vedrai apparire lobi laterali (leakage)</li>
                <li><strong>Applica diverse funzioni di finestra</strong> nel pannello "Funzioni di Finestra" per
                    ridurre il leakage</li>
            </ol>

            <div class="application-box">
                <p class="application-item">
                    <strong>üí° Cosa Imparerai:</strong> Capirai perch√© il windowing √® fondamentale nell'analisi
                    spettrale quando non puoi garantire un campionamento perfettamente sincrono con il segnale!
                </p>
            </div>

            <button onclick="closeModal('modalExercise4')" class="btn-primary">
                Inizia l'Esercizio üöÄ
            </button>
        </div>
    </div>

    <script>
        // ============================================
        // GESTIONE NAVIGAZIONE E MODALI
        // ============================================

        const navButtons = document.querySelectorAll('.nav-btn');
        const sections = document.querySelectorAll('.section');

        navButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const targetSection = btn.dataset.section;

                navButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                sections.forEach(s => s.classList.remove('active'));
                document.getElementById(targetSection).classList.add('active');

                // Ridimensiona i grafici quando si passa alla sezione laboratorio
                if (targetSection === 'laboratorio') {
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            const timeChart = document.getElementById('timeChart');
                            const freqChart = document.getElementById('freqChart');
                            if (timeChart && freqChart && timeChart.parentElement && freqChart.parentElement) {
                                // Calcola la larghezza disponibile sottraendo il padding
                                const parent = timeChart.parentElement;
                                const style = window.getComputedStyle(parent);
                                const paddingLeft = parseFloat(style.paddingLeft);
                                const paddingRight = parseFloat(style.paddingRight);
                                const width = parent.clientWidth - paddingLeft - paddingRight;
                                Plotly.relayout('timeChart', { width: width });
                                Plotly.relayout('freqChart', { width: width });
                            }
                        });
                    });
                }
            });
        });

        function openModal(modalId) {
            document.getElementById(modalId).style.display = 'block';
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        window.onclick = function (event) {
            if (event.target.classList.contains('modal')) {
                event.target.style.display = 'none';
            }
        }

        function switchTab(tabId) {
            const tabs = document.querySelectorAll('.modal-tab');
            const contents = document.querySelectorAll('.tab-content');

            tabs.forEach(t => t.classList.remove('active'));
            contents.forEach(c => c.classList.remove('active'));

            event.target.classList.add('active');
            document.getElementById(tabId).classList.add('active');
        }

        // ============================================
        // VARIABILI GLOBALI E CONFIGURAZIONE
        // ============================================

        let currentTimeData = [];
        let currentFreqData = [];
        let sampleRate = 8000; // Hz
        let numSamples = 1024;
        let syncSampling = true;

        // ============================================
        // GESTIONE PARAMETRI DI CAMPIONAMENTO
        // ============================================

        /**
         * Calcola il numero ottimale di campioni per campionamento sincrono
         * @param {number} signalFreq - Frequenza del segnale in Hz
         * @param {number} fs - Frequenza di campionamento in Hz
         * @param {number} targetSamples - Numero target di campioni (approssimativo)
         * @returns {number} - Numero di campioni che cattura un numero intero di periodi
         */
        function calculateSyncSamples(signalFreq, fs, targetSamples) {
            if (signalFreq === 0) return targetSamples;

            // Numero di campioni in un singolo periodo
            const samplesPerPeriod = fs / signalFreq;

            // Numero di periodi completi che si avvicinano al target
            const numPeriods = Math.round(targetSamples / samplesPerPeriod);

            // Numero di campioni che cattura esattamente numPeriods periodi
            const syncSamples = Math.round(numPeriods * samplesPerPeriod);

            return syncSamples;
        }

        /**
         * Trova la potenza di 2 pi√π vicina
         */
        function nearestPowerOf2(n) {
            return Math.pow(2, Math.round(Math.log2(n)));
        }

        /**
         * Aggiorna lo stato del campionamento e visualizza informazioni
         */
        function updateSamplingStatus() {
            const statusDiv = document.getElementById('samplingStatus');
            const signalFreq = parseFloat(document.getElementById('signalFreqInput').value) || 100;

            if (syncSampling) {
                const idealSamples = calculateSyncSamples(signalFreq, sampleRate, numSamples);
                const samplesPerPeriod = sampleRate / signalFreq;
                const numPeriods = Math.round(idealSamples / samplesPerPeriod);
                const isPowerOf2 = (idealSamples & (idealSamples - 1)) === 0;

                let statusHTML = '<div class="sync-ok">';
                statusHTML += '<strong>‚úì Campionamento Sincrono Attivo</strong><br>';
                statusHTML += `Frequenza segnale: ${signalFreq} Hz<br>`;
                statusHTML += `Campioni per periodo: ${samplesPerPeriod.toFixed(2)}<br>`;
                statusHTML += `Numero di periodi: ${numPeriods}<br>`;
                statusHTML += `Campioni totali: ${idealSamples}`;

                if (!isPowerOf2) {
                    const nearestPow2 = nearestPowerOf2(idealSamples);
                    statusHTML += `<br><span>‚ö† Nota: ${idealSamples} non √® una potenza di 2. Potenza di 2 pi√π vicina: ${nearestPow2}</span>`;
                }

                statusHTML += '</div>';
                statusDiv.innerHTML = statusHTML;

                // Aggiorna automaticamente il numero di campioni
                numSamples = idealSamples;
                document.getElementById('numSamplesInput').value = idealSamples;
            } else {
                const samplesPerPeriod = sampleRate / signalFreq;
                const numPeriods = numSamples / samplesPerPeriod;
                const isIntegerPeriods = Math.abs(numPeriods - Math.round(numPeriods)) < 0.01;

                let statusHTML = isIntegerPeriods ? '<div class="sync-ok">' : '<div class="sync-warning">';
                statusHTML += '<strong>' + (isIntegerPeriods ? '‚úì' : '‚ö†') + ' Campionamento Non Sincrono</strong><br>';
                statusHTML += `Frequenza segnale: ${signalFreq} Hz<br>`;
                statusHTML += `Campioni per periodo: ${samplesPerPeriod.toFixed(2)}<br>`;
                statusHTML += `Numero di periodi: ${numPeriods.toFixed(3)}`;

                if (!isIntegerPeriods) {
                    statusHTML += `<br><strong>Attenzione:</strong> Il numero di periodi non √® intero. Si verificher√† leakage spettrale (windowing effect).`;
                }

                statusHTML += '</div>';
                statusDiv.innerHTML = statusHTML;
            }

            // Verifica Nyquist - considera solo le frequenze con ampiezza > 0
            const amp1 = parseFloat(document.getElementById('amp1').value) || 0;
            const amp2 = parseFloat(document.getElementById('amp2').value) || 0;
            const amp3 = parseFloat(document.getElementById('amp3').value) || 0;
            const freq1 = parseFloat(document.getElementById('freq1').value) || 0;
            const freq2 = parseFloat(document.getElementById('freq2').value) || 0;
            const freq3 = parseFloat(document.getElementById('freq3').value) || 0;

            const activeFrequencies = [signalFreq];
            if (amp1 > 0) activeFrequencies.push(freq1);
            if (amp2 > 0) activeFrequencies.push(freq2);
            if (amp3 > 0) activeFrequencies.push(freq3);

            const maxSignalFreq = Math.max(...activeFrequencies);

            const nyquistFreq = sampleRate / 2;

            if (maxSignalFreq > nyquistFreq) {
                statusDiv.innerHTML += '<div class="sync-error">';
                statusDiv.innerHTML += '<strong>‚ö† ERRORE: Violazione del Teorema di Nyquist!</strong><br>';
                statusDiv.innerHTML += `La frequenza massima del segnale (${maxSignalFreq} Hz) supera la frequenza di Nyquist (${nyquistFreq} Hz).<br>`;
                statusDiv.innerHTML += `Aumenta la frequenza di campionamento ad almeno ${(maxSignalFreq * 2).toFixed(0)} Hz per evitare aliasing.`;
                statusDiv.innerHTML += '</div>';
            }
        }

        /**
         * Applica le impostazioni di campionamento
         */
        function applySamplingSettings() {
            const newSampleRate = parseFloat(document.getElementById('sampleRateInput').value);
            const newNumSamples = parseInt(document.getElementById('numSamplesInput').value);
            const newSyncSampling = document.getElementById('syncSamplingCheck').checked;

            // Validazione con limiti estesi
            if (isNaN(newSampleRate) || newSampleRate < 10 || newSampleRate > 10000000) {
                alert('Frequenza di campionamento non valida. Deve essere tra 10 Hz e 10 MHz.');
                return;
            }

            if (isNaN(newNumSamples) || newNumSamples < 64 || newNumSamples > 16384) {
                alert('Numero di campioni non valido. Deve essere tra 64 e 16384.');
                return;
            }

            // Aggiorna le variabili globali
            sampleRate = newSampleRate;
            numSamples = newNumSamples;
            syncSampling = newSyncSampling;

            // Aggiorna lo stato
            updateSamplingStatus();

            // Rigenera il segnale corrente con i nuovi parametri
            if (currentTimeData.length > 0) {
                // Rileva quale tipo di segnale √® attualmente visualizzato e rigenera
                const selectedType = document.querySelector('input[name="signalType"]:checked');
                if (selectedType) {
                    generatePredefinedSignal();
                } else {
                    updateCustomSignal();
                }
            }
        }

        // Event listener per il checkbox di campionamento sincrono
        document.getElementById('syncSamplingCheck').addEventListener('change', function () {
            syncSampling = this.checked;
            updateSamplingStatus();
        });

        // Event listener per aggiornare lo stato quando cambia la frequenza del segnale
        document.getElementById('signalFreqInput').addEventListener('input', function () {
            updateSamplingStatus();
        });

        // ============================================
        // FUNZIONE DFT (Discrete Fourier Transform)
        // ============================================

        /**
         * Calcola la DFT di un array di campioni reali
         * @param {Array} samples - Array di campioni reali
         * @returns {Object} - {magnitudes: Array, phases: Array, frequencies: Array}
         */
        function computeDFT(samples) {
            const N = samples.length;
            const magnitudes = [];
            const phases = [];
            const frequencies = [];

            // Calcoliamo solo la prima met√† dello spettro (frequenze positive)
            const halfN = Math.floor(N / 2);

            for (let k = 0; k < halfN; k++) {
                let realPart = 0;
                let imagPart = 0;

                // Sommatoria della DFT per la frequenza k
                for (let n = 0; n < N; n++) {
                    const angle = -2 * Math.PI * k * n / N;
                    realPart += samples[n] * Math.cos(angle);
                    imagPart += samples[n] * Math.sin(angle);
                }

                // Normalizzazione
                realPart /= N;
                imagPart /= N;

                // Calcolo magnitudine e fase
                const magnitude = 2 * Math.sqrt(realPart * realPart + imagPart * imagPart); // Fattore 2 per compensare la simmetria
                const phase = Math.atan2(imagPart, realPart) * 180 / Math.PI;

                magnitudes.push(magnitude);
                phases.push(phase);
                frequencies.push(k * sampleRate / N);
            }

            return { magnitudes, phases, frequencies };
        }

        // ============================================
        // FUNZIONI DI FINESTRA (WINDOWING)
        // ============================================

        /**
         * Genera diverse funzioni di finestra
         */
        function generateWindow(type, N) {
            const window = [];

            switch (type) {
                case 'rectangular':
                    for (let n = 0; n < N; n++) {
                        window.push(1.0);
                    }
                    break;

                case 'hanning':
                    for (let n = 0; n < N; n++) {
                        window.push(0.5 * (1 - Math.cos(2 * Math.PI * n / (N - 1))));
                    }
                    break;

                case 'hamming':
                    for (let n = 0; n < N; n++) {
                        window.push(0.54 - 0.46 * Math.cos(2 * Math.PI * n / (N - 1)));
                    }
                    break;

                case 'blackman':
                    for (let n = 0; n < N; n++) {
                        const a0 = 0.42;
                        const a1 = 0.5;
                        const a2 = 0.08;
                        window.push(a0 - a1 * Math.cos(2 * Math.PI * n / (N - 1)) +
                            a2 * Math.cos(4 * Math.PI * n / (N - 1)));
                    }
                    break;

                case 'bartlett':
                    for (let n = 0; n < N; n++) {
                        window.push(1 - Math.abs((n - (N - 1) / 2) / ((N - 1) / 2)));
                    }
                    break;

                case 'kaiser':
                    const beta = 5; // Parametro Kaiser
                    const I0_beta = besselI0(beta);
                    for (let n = 0; n < N; n++) {
                        const arg = beta * Math.sqrt(1 - Math.pow(2 * n / (N - 1) - 1, 2));
                        window.push(besselI0(arg) / I0_beta);
                    }
                    break;

                default:
                    for (let n = 0; n < N; n++) {
                        window.push(1.0);
                    }
            }

            return window;
        }

        /**
         * Funzione di Bessel I0 modificata (per finestra Kaiser)
         */
        function besselI0(x) {
            let sum = 1.0;
            let term = 1.0;
            const threshold = 1e-12;

            for (let k = 1; k < 50; k++) {
                term *= (x * x) / (4 * k * k);
                sum += term;
                if (term < threshold) break;
            }

            return sum;
        }

        /**
         * Applica la finestra selezionata al segnale corrente
         */
        let originalSignal = []; // Salva il segnale originale senza finestra
        let currentWindow = 'rectangular';

        function applyWindowFunction() {
            const windowType = document.getElementById('windowType').value;
            currentWindow = windowType;

            // Se non c'√® un segnale, genera uno di default
            if (currentTimeData.length === 0 && originalSignal.length === 0) {
                alert('Genera prima un segnale!');
                return;
            }

            // Se √® la prima volta, salva il segnale originale
            if (originalSignal.length === 0 || windowType === 'rectangular') {
                originalSignal = [...currentTimeData];
            }

            // Genera la finestra
            const window = generateWindow(windowType, originalSignal.length);

            // Applica la finestra al segnale originale
            const windowedSignal = [];
            for (let i = 0; i < originalSignal.length; i++) {
                windowedSignal.push(originalSignal[i] * window[i]);
            }

            // Aggiorna i grafici con il segnale finestratto
            updatePlots(windowedSignal);

            // Mostra informazioni sulla finestra
            showWindowInfo(windowType);
        }

        /**
         * Mostra informazioni sulla finestra selezionata
         */
        function showWindowInfo(windowType) {
            const infoDiv = document.getElementById('windowInfo');
            const descDiv = document.getElementById('windowDescription');

            const descriptions = {
                rectangular: 'Nessuna attenuazione. Usa solo se il segnale √® perfettamente sincronizzato. Produce il massimo leakage spettrale.',
                hanning: 'Finestra coseno alzato. Buon compromesso tra risoluzione e riduzione del leakage. Molto usata in applicazioni generali.',
                hamming: 'Simile a Hanning ma con migliore soppressione dei lobi laterali (-43 dB). Ottima per la maggior parte delle applicazioni.',
                blackman: 'Massima soppressione dei lobi laterali (-58 dB). Usa quando il leakage deve essere minimo, anche a costo di risoluzione.',
                bartlett: 'Finestra triangolare. Buona per segnali transitori con inizio/fine naturalmente attenuati.',
                kaiser: 'Finestra flessibile (Œ≤=5). Offre controllo preciso del compromesso tra risoluzione e leakage.'
            };

            descDiv.textContent = descriptions[windowType] || 'Informazioni non disponibili.';
            infoDiv.style.display = 'block';
        }

        /**
         * Mostra il modale di confronto delle finestre
         */
        function showWindowComparison() {
            openModal('modalWindowComparison');

            // Genera grafici di confronto
            setTimeout(() => {
                plotWindowShapes();
                plotWindowFrequencyResponses();
            }, 100);
        }

        /**
         * Plotta le forme delle finestre nel tempo
         */
        function plotWindowShapes() {
            const N = 512;
            const windowTypes = ['rectangular', 'hanning', 'hamming', 'blackman', 'bartlett', 'kaiser'];
            const windowNames = ['Rettangolare', 'Hanning', 'Hamming', 'Blackman', 'Bartlett', 'Kaiser'];
            const colors = ['#e74c3c', '#3498db', '#2ecc71', '#9b59b6', '#f39c12', '#1abc9c'];

            const traces = [];

            for (let i = 0; i < windowTypes.length; i++) {
                const window = generateWindow(windowTypes[i], N);
                const x = Array.from({ length: N }, (_, i) => i);

                traces.push({
                    x: x,
                    y: window,
                    type: 'scatter',
                    mode: 'lines',
                    name: windowNames[i],
                    line: { color: colors[i], width: 2 }
                });
            }

            const layout = {
                title: 'Forma delle Finestre (Dominio del Tempo)',
                xaxis: { title: 'Campione' },
                yaxis: { title: 'Ampiezza', range: [-0.1, 1.1] },
                showlegend: true,
                legend: { x: 1.05, y: 1 },
                margin: { l: 60, r: 150, t: 50, b: 60 }
            };

            Plotly.newPlot('windowShapeChart', traces, layout, { responsive: true, displaylogo: false });
        }

        /**
         * Plotta le risposte in frequenza delle finestre
         */
        function plotWindowFrequencyResponses() {
            const N = 512;
            const windowTypes = ['rectangular', 'hanning', 'hamming', 'blackman', 'bartlett', 'kaiser'];
            const windowNames = ['Rettangolare', 'Hanning', 'Hamming', 'Blackman', 'Bartlett', 'Kaiser'];
            const colors = ['#e74c3c', '#3498db', '#2ecc71', '#9b59b6', '#f39c12', '#1abc9c'];

            const traces = [];

            for (let i = 0; i < windowTypes.length; i++) {
                const window = generateWindow(windowTypes[i], N);

                // Calcola DFT della finestra (zero-padded per migliore risoluzione)
                const paddedWindow = [...window, ...Array(N * 3).fill(0)];
                const dftResult = computeDFT(paddedWindow);

                // Converti in dB e normalizza
                const maxMag = Math.max(...dftResult.magnitudes);
                const magnitudesDB = dftResult.magnitudes.map(m => 20 * Math.log10(m / maxMag));

                // Prendi solo le prime frequenze significative
                const numPoints = Math.min(500, magnitudesDB.length);

                traces.push({
                    x: Array.from({ length: numPoints }, (_, i) => i),
                    y: magnitudesDB.slice(0, numPoints),
                    type: 'scatter',
                    mode: 'lines',
                    name: windowNames[i],
                    line: { color: colors[i], width: 2 }
                });
            }

            const layout = {
                title: 'Risposta in Frequenza delle Finestre (Normalizzata)',
                xaxis: { title: 'Bin di Frequenza' },
                yaxis: { title: 'Magnitudine (dB)', range: [-100, 5] },
                showlegend: true,
                legend: { x: 1.05, y: 1 },
                margin: { l: 60, r: 150, t: 50, b: 60 }
            };

            Plotly.newPlot('windowFreqChart', traces, layout, { responsive: true, displaylogo: false });
        }

        // ============================================
        // CONFRONTO CAMPIONAMENTO SINCRONO
        // ============================================

        /**
         * Mostra il modale di confronto campionamento sincrono vs non sincrono
         */
        function showSyncComparison() {
            openModal('modalSyncComparison');

            // Genera il confronto con i parametri di default
            setTimeout(() => {
                generateComparison();
            }, 100);
        }

        /**
         * Genera il confronto side-by-side tra campionamento sincrono e non sincrono
         */
        function generateComparison() {
            // Leggi parametri dall'interfaccia
            const signalFreq = parseFloat(document.getElementById('compFreq').value);
            const fs = parseFloat(document.getElementById('compSampleRate').value);
            const targetSamples = parseInt(document.getElementById('compSamples').value);

            // Calcola numero di campioni per campionamento sincrono
            const samplesPerPeriod = fs / signalFreq;
            const numPeriods = Math.round(targetSamples / samplesPerPeriod);
            const syncSamples = Math.round(numPeriods * samplesPerPeriod);

            // Numero di campioni non sincrono (fisso al target)
            const nonsyncSamples = targetSamples;

            // Genera segnali
            const syncSignal = [];
            const nonsyncSignal = [];

            for (let i = 0; i < syncSamples; i++) {
                const t = i / fs;
                syncSignal.push(Math.sin(2 * Math.PI * signalFreq * t));
            }

            for (let i = 0; i < nonsyncSamples; i++) {
                const t = i / fs;
                nonsyncSignal.push(Math.sin(2 * Math.PI * signalFreq * t));
            }

            // Calcola FFT
            const syncDFT = computeDFT(syncSignal);
            const nonsyncDFT = computeDFT(nonsyncSignal);

            // Calcola frequenze
            const syncFreqs = syncDFT.frequencies.map((_, i) => (i * fs) / syncSamples);
            const nonsyncFreqs = nonsyncDFT.frequencies.map((_, i) => (i * fs) / nonsyncSamples);

            // Calcola periodi catturati
            const syncPeriodsCaptured = (syncSamples / fs) * signalFreq;
            const nonsyncPeriodsCaptured = (nonsyncSamples / fs) * signalFreq;

            // Aggiorna informazioni
            document.getElementById('syncSamplesInfo').textContent = syncSamples;
            document.getElementById('syncPeriodsInfo').textContent = syncPeriodsCaptured.toFixed(1) + ' periodi';
            document.getElementById('syncDurationInfo').textContent = (syncSamples / fs * 1000).toFixed(2) + ' ms';

            document.getElementById('nonsyncSamplesInfo').textContent = nonsyncSamples;
            document.getElementById('nonsyncPeriodsInfo').textContent = nonsyncPeriodsCaptured.toFixed(3) + ' periodi';
            document.getElementById('nonsyncDurationInfo').textContent = (nonsyncSamples / fs * 1000).toFixed(2) + ' ms';

            document.getElementById('comparisonInfo').style.display = 'block';

            // Plotta segnali nel tempo
            plotComparisonTime(syncSignal, nonsyncSignal, fs, signalFreq);

            // Plotta spettri in frequenza
            plotComparisonFreq(syncFreqs, syncDFT.magnitudes, nonsyncFreqs, nonsyncDFT.magnitudes, signalFreq);

            // Analisi differenze
            analyzeComparison(syncDFT, nonsyncDFT, syncFreqs, nonsyncFreqs, signalFreq);
        }

        /**
         * Plotta i segnali nel tempo per il confronto
         */
        function plotComparisonTime(syncSignal, nonsyncSignal, fs, signalFreq) {
            // Segnale sincrono
            const syncTime = syncSignal.map((_, i) => i / fs * 1000); // in ms
            const syncTrace = {
                x: syncTime,
                y: syncSignal,
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Campioni',
                line: { color: '#27ae60', width: 2 },
                marker: { size: 4, color: '#27ae60' }
            };

            const syncLayout = {
                xaxis: { title: 'Tempo (ms)' },
                yaxis: { title: 'Ampiezza', range: [-1.2, 1.2] },
                showlegend: false,
                margin: { l: 50, r: 20, t: 20, b: 50 }
            };

            Plotly.newPlot('syncTimeChart', [syncTrace], syncLayout, { responsive: true, displaylogo: false });

            // Segnale non sincrono
            const nonsyncTime = nonsyncSignal.map((_, i) => i / fs * 1000); // in ms
            const nonsyncTrace = {
                x: nonsyncTime,
                y: nonsyncSignal,
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Campioni',
                line: { color: '#e74c3c', width: 2 },
                marker: { size: 4, color: '#e74c3c' }
            };

            const nonsyncLayout = {
                xaxis: { title: 'Tempo (ms)' },
                yaxis: { title: 'Ampiezza', range: [-1.2, 1.2] },
                showlegend: false,
                margin: { l: 50, r: 20, t: 20, b: 50 }
            };

            Plotly.newPlot('nonsyncTimeChart', [nonsyncTrace], nonsyncLayout, { responsive: true, displaylogo: false });
        }

        /**
         * Plotta gli spettri in frequenza per il confronto
         */
        function plotComparisonFreq(syncFreqs, syncMags, nonsyncFreqs, nonsyncMags, signalFreq) {
            // Converti in dB
            const maxSyncMag = Math.max(...syncMags);
            const maxNonsyncMag = Math.max(...nonsyncMags);

            const syncMagsDB = syncMags.map(m => 20 * Math.log10(m / maxSyncMag));
            const nonsyncMagsDB = nonsyncMags.map(m => 20 * Math.log10(m / maxNonsyncMag));

            // Limita la visualizzazione a frequenze significative
            const maxFreq = signalFreq * 3;
            const syncLimit = syncFreqs.findIndex(f => f > maxFreq);
            const nonsyncLimit = nonsyncFreqs.findIndex(f => f > maxFreq);

            // Spettro sincrono
            const syncTrace = {
                x: syncFreqs.slice(0, syncLimit),
                y: syncMagsDB.slice(0, syncLimit),
                type: 'scatter',
                mode: 'lines',
                name: 'Spettro',
                line: { color: '#27ae60', width: 2 },
                fill: 'tozeroy',
                fillcolor: 'rgba(39, 174, 96, 0.2)'
            };

            const syncLayout = {
                xaxis: { title: 'Frequenza (Hz)' },
                yaxis: { title: 'Magnitudine (dB)', range: [-80, 5] },
                showlegend: false,
                margin: { l: 50, r: 20, t: 20, b: 50 },
                shapes: [{
                    type: 'line',
                    x0: signalFreq,
                    x1: signalFreq,
                    y0: -80,
                    y1: 5,
                    line: { color: '#2c3e50', width: 2, dash: 'dash' }
                }]
            };

            Plotly.newPlot('syncFreqChart', [syncTrace], syncLayout, { responsive: true, displaylogo: false });

            // Spettro non sincrono
            const nonsyncTrace = {
                x: nonsyncFreqs.slice(0, nonsyncLimit),
                y: nonsyncMagsDB.slice(0, nonsyncLimit),
                type: 'scatter',
                mode: 'lines',
                name: 'Spettro',
                line: { color: '#e74c3c', width: 2 },
                fill: 'tozeroy',
                fillcolor: 'rgba(231, 76, 60, 0.2)'
            };

            const nonsyncLayout = {
                xaxis: { title: 'Frequenza (Hz)' },
                yaxis: { title: 'Magnitudine (dB)', range: [-80, 5] },
                showlegend: false,
                margin: { l: 50, r: 20, t: 20, b: 50 },
                shapes: [{
                    type: 'line',
                    x0: signalFreq,
                    x1: signalFreq,
                    y0: -80,
                    y1: 5,
                    line: { color: '#2c3e50', width: 2, dash: 'dash' }
                }]
            };

            Plotly.newPlot('nonsyncFreqChart', [nonsyncTrace], nonsyncLayout, { responsive: true, displaylogo: false });
        }

        /**
         * Analizza e mostra le differenze tra i due spettri
         */
        function analyzeComparison(syncDFT, nonsyncDFT, syncFreqs, nonsyncFreqs, signalFreq) {
            // Trova l'indice del picco principale
            const syncPeakIdx = syncDFT.magnitudes.indexOf(Math.max(...syncDFT.magnitudes));
            const nonsyncPeakIdx = nonsyncDFT.magnitudes.indexOf(Math.max(...nonsyncDFT.magnitudes));

            // Calcola la larghezza del picco (a -3dB)
            const syncPeakMag = syncDFT.magnitudes[syncPeakIdx];
            const nonsyncPeakMag = nonsyncDFT.magnitudes[nonsyncPeakIdx];

            // Calcola il rapporto picco/lobi laterali (PSLR - Peak Sidelobe Ratio)
            const syncSidelobes = syncDFT.magnitudes.filter((_, i) => Math.abs(i - syncPeakIdx) > 5);
            const nonsyncSidelobes = nonsyncDFT.magnitudes.filter((_, i) => Math.abs(i - nonsyncPeakIdx) > 5);

            const syncMaxSidelobe = Math.max(...syncSidelobes);
            const nonsyncMaxSidelobe = Math.max(...nonsyncSidelobes);

            const syncPSLR = 20 * Math.log10(syncPeakMag / syncMaxSidelobe);
            const nonsyncPSLR = 20 * Math.log10(nonsyncPeakMag / nonsyncMaxSidelobe);

            // Genera analisi testuale
            const analysisHTML = `
                <p><strong>üìä Rapporto Picco/Lobi Laterali (PSLR):</strong></p>
                <ul>
                    <li><strong>Campionamento Sincrono:</strong> ${syncPSLR.toFixed(1)} dB 
                        <span>‚úì Eccellente soppressione</span></li>
                    <li><strong>Campionamento Non Sincrono:</strong> ${nonsyncPSLR.toFixed(1)} dB 
                        <span>‚ö†Ô∏è Lobi laterali significativi</span></li>
                </ul>
                
                <p><strong>üéØ Precisione del Picco:</strong></p>
                <ul>
                    <li><strong>Campionamento Sincrono:</strong> Picco centrato esattamente a ${syncFreqs[syncPeakIdx].toFixed(1)} Hz 
                        (atteso: ${signalFreq} Hz)</li>
                    <li><strong>Campionamento Non Sincrono:</strong> Picco a ${nonsyncFreqs[nonsyncPeakIdx].toFixed(1)} Hz 
                        con dispersione sulle frequenze adiacenti</li>
                </ul>

                <p><strong>üí° Differenza:</strong> 
                    ${syncPSLR > nonsyncPSLR ?
                    `Il campionamento sincrono ha una soppressione dei lobi laterali migliore di <strong>${(syncPSLR - nonsyncPSLR).toFixed(1)} dB</strong>. 
                        Questo significa che eventuali altre frequenze presenti nel segnale sarebbero molto pi√π facili da identificare.` :
                    `Il campionamento presenta leakage significativo.`
                }
                </p>
            `;

            document.getElementById('comparisonAnalysis').innerHTML = analysisHTML;
        }

        // ============================================
        // GENERATORI DI SEGNALI PREDEFINITI
        // ============================================

        function generateSine(freq, amplitude, samples, sr) {
            const signal = [];
            for (let i = 0; i < samples; i++) {
                const t = i / sr;
                signal.push(amplitude * Math.sin(2 * Math.PI * freq * t));
            }
            return signal;
        }

        function generateSquare(freq, amplitude, samples, sr) {
            const signal = [];
            const period = sr / freq;
            for (let i = 0; i < samples; i++) {
                const phase = (i % period) / period;
                signal.push(phase < 0.5 ? amplitude : -amplitude);
            }
            return signal;
        }

        function generateTriangle(freq, amplitude, samples, sr) {
            const signal = [];
            const period = sr / freq;
            for (let i = 0; i < samples; i++) {
                const phase = (i % period) / period;
                if (phase < 0.25) {
                    signal.push(amplitude * 4 * phase);
                } else if (phase < 0.75) {
                    signal.push(amplitude * (2 - 4 * phase));
                } else {
                    signal.push(amplitude * (4 * phase - 4));
                }
            }
            return signal;
        }

        function generateNoise(amplitude, samples) {
            const signal = [];
            for (let i = 0; i < samples; i++) {
                signal.push(amplitude * (Math.random() * 2 - 1));
            }
            return signal;
        }

        // ============================================
        // GENERAZIONE SEGNALI PREDEFINITI
        // ============================================

        function generatePredefinedSignal() {
            const selectedType = document.querySelector('input[name="signalType"]:checked').value;
            const signalFreq = parseFloat(document.getElementById('signalFreqInput').value) || 100;

            // Aggiorna il numero di campioni se campionamento sincrono √® attivo
            if (syncSampling && selectedType !== 'noise') {
                let calculatedSamples = calculateSyncSamples(signalFreq, sampleRate, numSamples);

                // Limita il numero di campioni a valori ragionevoli
                if (calculatedSamples < 64) {
                    calculatedSamples = 64;
                    console.warn(`Numero di campioni troppo basso, impostato a 64`);
                } else if (calculatedSamples > 8192) {
                    calculatedSamples = 8192;
                    console.warn(`Numero di campioni troppo alto, impostato a 8192`);
                }

                numSamples = calculatedSamples;
                document.getElementById('numSamplesInput').value = numSamples;
            }

            updateSamplingStatus();

            let signal;

            switch (selectedType) {
                case 'sine':
                    signal = generateSine(signalFreq, 1, numSamples, sampleRate);
                    break;
                case 'square':
                    signal = generateSquare(signalFreq, 1, numSamples, sampleRate);
                    break;
                case 'triangle':
                    signal = generateTriangle(signalFreq, 1, numSamples, sampleRate);
                    break;
                case 'noise':
                    signal = generateNoise(0.5, numSamples);
                    break;
            }

            // Salva il segnale originale e resetta la finestra
            originalSignal = [...signal];
            document.getElementById('windowType').value = 'rectangular';
            currentWindow = 'rectangular';

            updatePlots(signal);
        }

        // ============================================
        // COSTRUTTORE SEGNALI CUSTOM
        // ============================================

        function updateCustomSignal() {
            // Leggi i valori degli slider
            const amp1 = parseFloat(document.getElementById('amp1').value);
            const freq1 = parseFloat(document.getElementById('freq1').value);
            const phase1 = parseFloat(document.getElementById('phase1').value);

            const amp2 = parseFloat(document.getElementById('amp2').value);
            const freq2 = parseFloat(document.getElementById('freq2').value);
            const phase2 = parseFloat(document.getElementById('phase2').value);

            const amp3 = parseFloat(document.getElementById('amp3').value);
            const freq3 = parseFloat(document.getElementById('freq3').value);
            const phase3 = parseFloat(document.getElementById('phase3').value);

            // Aggiorna i display dei valori
            document.getElementById('amp1-val').textContent = amp1.toFixed(2);
            document.getElementById('freq1-val').textContent = freq1;
            document.getElementById('phase1-val').textContent = phase1;

            document.getElementById('amp2-val').textContent = amp2.toFixed(2);
            document.getElementById('freq2-val').textContent = freq2;
            document.getElementById('phase2-val').textContent = phase2;

            document.getElementById('amp3-val').textContent = amp3.toFixed(2);
            document.getElementById('freq3-val').textContent = freq3;
            document.getElementById('phase3-val').textContent = phase3;

            // Trova la frequenza fondamentale (la pi√π bassa con ampiezza > 0)
            const fundamentalFreq = amp1 > 0 ? freq1 : (amp2 > 0 ? freq2 : (amp3 > 0 ? freq3 : 100));

            // Aggiorna il numero di campioni se campionamento sincrono √® attivo
            if (syncSampling) {
                let calculatedSamples = calculateSyncSamples(fundamentalFreq, sampleRate, numSamples);

                // Limita il numero di campioni a valori ragionevoli
                if (calculatedSamples < 64) {
                    calculatedSamples = 64;
                    console.warn(`Numero di campioni troppo basso, impostato a 64`);
                } else if (calculatedSamples > 8192) {
                    calculatedSamples = 8192;
                    console.warn(`Numero di campioni troppo alto, impostato a 8192`);
                }

                numSamples = calculatedSamples;
                document.getElementById('numSamplesInput').value = numSamples;
            }

            updateSamplingStatus();

            // Genera il segnale come somma delle tre sinusoidi
            const signal = [];
            for (let i = 0; i < numSamples; i++) {
                const t = i / sampleRate;
                const s1 = amp1 * Math.sin(2 * Math.PI * freq1 * t + phase1 * Math.PI / 180);
                const s2 = amp2 * Math.sin(2 * Math.PI * freq2 * t + phase2 * Math.PI / 180);
                const s3 = amp3 * Math.sin(2 * Math.PI * freq3 * t + phase3 * Math.PI / 180);
                signal.push(s1 + s2 + s3);
            }

            // Salva il segnale originale e resetta la finestra
            originalSignal = [...signal];
            document.getElementById('windowType').value = 'rectangular';
            currentWindow = 'rectangular';

            updatePlots(signal);
        }

        // ============================================
        // AGGIORNAMENTO GRAFICI
        // ============================================

        function updatePlots(signal) {
            currentTimeData = signal;

            // Validazione del segnale
            if (!signal || signal.length === 0) {
                console.error('Segnale vuoto o non valido');
                return;
            }

            // Grafico nel dominio del tempo
            // Usa il numero effettivo di campioni del segnale, non la variabile globale
            const actualNumSamples = signal.length;
            const timeAxis = [];
            for (let i = 0; i < actualNumSamples; i++) {
                timeAxis.push(i / sampleRate);
            }

            const timeTrace = {
                x: timeAxis,
                y: signal,
                type: 'scatter',
                mode: 'lines',
                line: { color: '#3498db', width: 2 },
                name: 'Segnale'
            };

            // Calcola la durata totale del segnale per impostare un range appropriato
            const duration = actualNumSamples / sampleRate;

            // Assicurati che la durata sia ragionevole
            const minDuration = 0.001; // 1 ms minimo
            const maxDuration = 10;    // 10 s massimo
            const safeDuration = Math.max(minDuration, Math.min(duration, maxDuration));

            console.log(`Aggiornamento grafico: ${actualNumSamples} campioni, durata ${duration.toFixed(4)}s, Fs=${sampleRate} Hz`);

            // Determina il titolo in base alla finestra applicata
            let timeTitle = 'Segnale nel Dominio del Tempo';
            if (currentWindow && currentWindow !== 'rectangular') {
                const windowNames = {
                    hanning: 'Hanning',
                    hamming: 'Hamming',
                    blackman: 'Blackman',
                    bartlett: 'Bartlett',
                    kaiser: 'Kaiser'
                };
                timeTitle += ` (Finestra: ${windowNames[currentWindow]})`;
            }

            const timeLayout = {
                title: timeTitle,
                xaxis: {
                    title: 'Tempo (s)',
                    range: [0, safeDuration],
                    autorange: false
                },
                yaxis: {
                    title: 'Ampiezza',
                    autorange: true
                },
                margin: { t: 60, r: 40, b: 60, l: 60 },
                plot_bgcolor: '#f8f9fa',
                paper_bgcolor: '#ffffff',
                autosize: true
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            };

            Plotly.newPlot('timeChart', [timeTrace], timeLayout, config).then(() => {
                // Usa requestAnimationFrame per attendere il render completo del browser
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        const container = document.getElementById('timeChart');
                        // Calcola la larghezza disponibile sottraendo il padding
                        const parent = container.parentElement;
                        const style = window.getComputedStyle(parent);
                        const paddingLeft = parseFloat(style.paddingLeft);
                        const paddingRight = parseFloat(style.paddingRight);
                        const width = parent.clientWidth - paddingLeft - paddingRight;
                        const height = 450;
                        Plotly.relayout('timeChart', {
                            width: width,
                            height: height
                        });
                    });
                });
            });

            // Calcola e plotta lo spettro
            updateFrequencyPlot();
        }

        function updateFrequencyPlot() {
            if (currentTimeData.length === 0) return;

            // Calcola la DFT
            const dftResult = computeDFT(currentTimeData);
            currentFreqData = dftResult;

            const scaleType = document.querySelector('input[name="scaleType"]:checked').value;

            let yData;
            let yLabel;

            if (scaleType === 'linear') {
                yData = dftResult.magnitudes;
                yLabel = 'Ampiezza';
            } else {
                // Scala logaritmica (dB): 20*log10(magnitude)
                yData = dftResult.magnitudes.map(m => 20 * Math.log10(Math.max(m, 1e-10))); // Evita log(0)
                yLabel = 'Ampiezza (dB)';
            }

            const freqTrace = {
                x: dftResult.frequencies,
                y: yData,
                type: 'scatter',
                mode: 'lines',
                fill: 'tozeroy',
                line: { color: '#e74c3c', width: 2 },
                fillcolor: 'rgba(231, 76, 60, 0.3)',
                name: 'Spettro'
            };

            // Calcola il range di frequenze significativo (fino alla frequenza di Nyquist)
            const maxFreq = Math.min(sampleRate / 2, Math.max(...dftResult.frequencies));

            const freqLayout = {
                title: 'Spettro nel Dominio della Frequenza',
                xaxis: {
                    title: 'Frequenza (Hz)',
                    range: [0, maxFreq],
                    autorange: false
                },
                yaxis: {
                    title: yLabel,
                    autorange: true
                },
                margin: { t: 60, r: 40, b: 60, l: 60 },
                plot_bgcolor: '#f8f9fa',
                paper_bgcolor: '#ffffff',
                autosize: true
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            };

            Plotly.newPlot('freqChart', [freqTrace], freqLayout, config).then(() => {
                // Usa requestAnimationFrame per attendere il render completo del browser
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        const container = document.getElementById('freqChart');
                        // Calcola la larghezza disponibile sottraendo il padding
                        const parent = container.parentElement;
                        const style = window.getComputedStyle(parent);
                        const paddingLeft = parseFloat(style.paddingLeft);
                        const paddingRight = parseFloat(style.paddingRight);
                        const width = parent.clientWidth - paddingLeft - paddingRight;
                        const height = 450;
                        Plotly.relayout('freqChart', {
                            width: width,
                            height: height
                        });
                    });
                });
            });
        }

        // ============================================
        // IMPORTAZIONE FILE
        // ============================================

        document.getElementById('fileImport').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (!file) return;

            const fileFormat = document.querySelector('input[name="fileFormat"]:checked').value;
            const reader = new FileReader();

            reader.onload = function (event) {
                const content = event.target.result;

                if (fileFormat === 'csv') {
                    parseCSV(content);
                } else if (fileFormat === 'picoscope') {
                    parsePicoscope(content);
                }
            };

            reader.readAsText(file);
        });

        function parseCSV(content) {
            Papa.parse(content, {
                skipEmptyLines: true,
                complete: function (results) {
                    const data = results.data;
                    const signal = [];

                    // Assume che la prima colonna sia il tempo e la seconda il valore
                    for (let i = 1; i < data.length; i++) { // Salta header se presente
                        const row = data[i];
                        if (row.length >= 2 && !isNaN(parseFloat(row[1]))) {
                            signal.push(parseFloat(row[1]));
                        }
                    }

                    if (signal.length > 0) {
                        // Ricampiona a numSamples se necessario
                        const resampledSignal = resampleSignal(signal, numSamples);
                        updatePlots(resampledSignal);
                    } else {
                        alert('Nessun dato valido trovato nel file CSV.');
                    }
                }
            });
        }

        function parsePicoscope(content) {
            Papa.parse(content, {
                skipEmptyLines: true,
                complete: function (results) {
                    const data = results.data;
                    const signal = [];
                    let startIndex = 0;

                    // Cerca l'inizio dei dati numerici (salta header testuali)
                    for (let i = 0; i < Math.min(10, data.length); i++) {
                        const row = data[i];
                        // Se la prima colonna contiene testo non numerico, √® un header
                        if (row.length > 0 && isNaN(parseFloat(row[0]))) {
                            startIndex = i + 1;
                        } else {
                            break;
                        }
                    }

                    // Leggi i dati dalla colonna del segnale (assume colonna 1 = tempo, colonna 2 = valore)
                    for (let i = startIndex; i < data.length; i++) {
                        const row = data[i];
                        if (row.length >= 2 && !isNaN(parseFloat(row[1]))) {
                            signal.push(parseFloat(row[1]));
                        }
                    }

                    if (signal.length > 0) {
                        const resampledSignal = resampleSignal(signal, numSamples);
                        updatePlots(resampledSignal);
                    } else {
                        alert('Nessun dato valido trovato nel file Picoscope.');
                    }
                }
            });
        }

        function resampleSignal(signal, targetLength) {
            if (signal.length === targetLength) return signal;

            const resampled = [];
            const ratio = signal.length / targetLength;

            for (let i = 0; i < targetLength; i++) {
                const index = Math.floor(i * ratio);
                resampled.push(signal[index]);
            }

            return resampled;
        }

        // ============================================
        // ESPORTAZIONE DATI
        // ============================================

        function exportSpectrum() {
            if (currentFreqData.frequencies.length === 0) {
                alert('Nessun dato da esportare. Genera o importa un segnale prima.');
                return;
            }

            let csvContent = "Frequenza_Hz,Ampiezza_Lineare,Fase_Gradi\n";

            for (let i = 0; i < currentFreqData.frequencies.length; i++) {
                csvContent += `${currentFreqData.frequencies[i].toFixed(2)},${currentFreqData.magnitudes[i].toFixed(6)},${currentFreqData.phases[i].toFixed(2)}\n`;
            }

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", "spettro_fourier.csv");
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        /**
         * Esporta lo spettro insieme ai parametri di campionamento usati
         */
        function exportWithParameters() {
            if (currentFreqData.frequencies.length === 0) {
                alert('Nessun dato da esportare. Genera o importa un segnale prima.');
                return;
            }

            // Ottieni la finestra corrente
            const windowType = document.getElementById('windowType').value;
            const windowNames = {
                'rectangular': 'Rettangolare',
                'hanning': 'Hanning',
                'hamming': 'Hamming',
                'blackman': 'Blackman',
                'bartlett': 'Bartlett',
                'kaiser': 'Kaiser'
            };

            // Prepara i metadati
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            let csvContent = "# PARAMETRI DI CAMPIONAMENTO E ANALISI\n";
            csvContent += `# Data e Ora: ${new Date().toLocaleString('it-IT')}\n`;
            csvContent += `# Frequenza di Campionamento: ${sampleRate} Hz\n`;
            csvContent += `# Numero di Campioni: ${numSamples}\n`;
            csvContent += `# Campionamento Sincrono: ${syncSampling ? 'S√¨' : 'No'}\n`;
            csvContent += `# Durata Finestra Temporale: ${(numSamples / sampleRate * 1000).toFixed(2)} ms\n`;
            csvContent += `# Risoluzione in Frequenza: ${(sampleRate / numSamples).toFixed(2)} Hz\n`;
            csvContent += `# Frequenza Nyquist: ${(sampleRate / 2).toFixed(2)} Hz\n`;
            csvContent += `# Funzione di Finestra: ${windowNames[windowType] || 'Nessuna'}\n`;
            csvContent += `# Numero di Punti nello Spettro: ${currentFreqData.frequencies.length}\n`;
            csvContent += "#\n";
            csvContent += "# DATI DELLO SPETTRO\n";
            csvContent += "Frequenza_Hz,Ampiezza_Lineare,Ampiezza_dB,Fase_Gradi\n";

            // Aggiungi i dati dello spettro
            for (let i = 0; i < currentFreqData.frequencies.length; i++) {
                const ampDB = 20 * Math.log10(currentFreqData.magnitudes[i] + 1e-10);
                csvContent += `${currentFreqData.frequencies[i].toFixed(2)},${currentFreqData.magnitudes[i].toFixed(6)},${ampDB.toFixed(2)},${currentFreqData.phases[i].toFixed(2)}\n`;
            }

            // Download del file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", `spettro_completo_${timestamp}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // ============================================
        // PRESET DIDATTICI
        // ============================================

        /**
         * Carica preset didattici pre-configurati
         */
        function loadPreset(presetName) {
            const presets = {
                'audio-cd': {
                    name: 'Audio CD Standard',
                    sampleRate: 44100,
                    numSamples: 2048,
                    syncSampling: true,
                    signalFreq: 440,
                    description: 'üéµ <strong>Audio CD (44.1 kHz)</strong><br>Standard di qualit√† CD audio. Pu√≤ catturare frequenze fino a 22.05 kHz (limite udibile ~20 kHz). Usato in musica digitale professionale.'
                },
                'audio-hd': {
                    name: 'Audio HD',
                    sampleRate: 48000,
                    numSamples: 2048,
                    syncSampling: true,
                    signalFreq: 1000,
                    description: 'üéß <strong>Audio HD (48 kHz)</strong><br>Standard per produzioni video e audio professionale. Frequenza massima 24 kHz. Usato in cinema, broadcasting e produzione musicale.'
                },
                'telephony': {
                    name: 'Telefonia',
                    sampleRate: 8000,
                    numSamples: 512,
                    syncSampling: true,
                    signalFreq: 1000,
                    description: 'üìû <strong>Telefonia (8 kHz)</strong><br>Standard telefonico (banda vocale 300-3400 Hz). Ottimizzato per la voce umana con minima larghezza di banda. Usato in VoIP e telefonia mobile.'
                },
                'ultrasound': {
                    name: 'Ultrasuoni Medici',
                    sampleRate: 1000000,
                    numSamples: 4096,
                    syncSampling: true,
                    signalFreq: 100000,
                    description: 'ü©∫ <strong>Ultrasuoni (1 MHz)</strong><br>Imaging medicale ad ultrasuoni. Frequenze da 1 a 20 MHz per diagnostica. Usato in ecografie e diagnosi medica non invasiva.'
                },
                'seismic': {
                    name: 'Acquisizione Sismica',
                    sampleRate: 100,
                    numSamples: 512,
                    syncSampling: true,
                    signalFreq: 10,
                    description: 'üåä <strong>Sismico (100 Hz)</strong><br>Monitoraggio sismico e onde oceaniche. Frequenze basse (0.1-50 Hz). Usato in geofisica, rilevamento terremoti e analisi onde marine.'
                },
                'eeg': {
                    name: 'Elettroencefalogramma',
                    sampleRate: 256,
                    numSamples: 1024,
                    syncSampling: false,
                    signalFreq: 10,
                    description: 'üß† <strong>EEG (256 Hz)</strong><br>Monitoraggio attivit√† cerebrale. Onde cerebrali 0.5-40 Hz (delta, theta, alpha, beta). Usato in neuroscienze e diagnosi neurologica.'
                },
                'radar': {
                    name: 'Radar Doppler',
                    sampleRate: 10000,
                    numSamples: 2048,
                    syncSampling: false,
                    signalFreq: 1000,
                    description: 'üì° <strong>Radar (10 kHz)</strong><br>Analisi Doppler per velocit√† e movimento. Frequenze di battimento fino a 5 kHz. Usato in radar meteorologico, auto e traffico.'
                },
                'vibration': {
                    name: 'Analisi Vibrazioni',
                    sampleRate: 2000,
                    numSamples: 2048,
                    syncSampling: false,
                    signalFreq: 100,
                    description: '‚öôÔ∏è <strong>Vibrazioni (2 kHz)</strong><br>Manutenzione predittiva di macchinari. Frequenze tipiche 10-1000 Hz. Usato per rilevare guasti in motori, cuscinetti e turbine.'
                }
            };

            const preset = presets[presetName];
            if (!preset) return;

            // Aggiorna i valori nell'interfaccia
            document.getElementById('sampleRateInput').value = preset.sampleRate;
            document.getElementById('numSamplesInput').value = preset.numSamples;
            document.getElementById('syncSamplingCheck').checked = preset.syncSampling;

            // Aggiorna anche la frequenza del segnale per evitare violazione di Nyquist
            document.getElementById('signalFreqInput').value = preset.signalFreq;

            // Azzera le ampiezze del costruttore di segnali per evitare false violazioni di Nyquist
            // (se amp = 0, quelle frequenze non sono nel segnale)
            document.getElementById('amp1').value = 0;
            document.getElementById('amp2').value = 0;
            document.getElementById('amp3').value = 0;

            // Mostra info preset
            const presetInfo = document.getElementById('presetInfo');
            presetInfo.innerHTML = preset.description;
            presetInfo.style.display = 'block';

            // Applica le impostazioni
            applySamplingSettings();

            // Genera il segnale sinusoidale con la frequenza del preset
            generateSignalWithFrequency(preset.signalFreq);

            // Feedback visivo
            setTimeout(() => {
                presetInfo.style.background = '#d4edda';
                presetInfo.style.borderLeftColor = '#28a745';
                presetInfo.innerHTML = `‚úÖ Preset "${preset.name}" caricato con successo!<br><br>${preset.description}`;
            }, 100);

            setTimeout(() => {
                presetInfo.style.background = '#e8f4f8';
                presetInfo.style.borderLeftColor = '#3498db';
            }, 3000);
        }

        /**
         * Genera un segnale sinusoidale puro con la frequenza specificata
         * Utilizzato dai preset per mostrare un segnale di esempio
         */
        function generateSignalWithFrequency(frequency) {
            const signal = [];
            const omega = 2 * Math.PI * frequency;

            for (let i = 0; i < numSamples; i++) {
                const t = i / sampleRate;
                signal[i] = Math.sin(omega * t);
            }

            currentTimeData = signal;
            plotSignal(signal, `Sinusoide ${frequency} Hz`);
            plotSpectrum(signal);
        }

        // ============================================
        // ESERCIZI GUIDATI
        // ============================================

        function setupExercise1() {
            // Passa alla sezione laboratorio
            document.querySelector('[data-section="laboratorio"]').click();

            // Imposta i parametri per costruire un'onda quadra
            setTimeout(() => {
                document.getElementById('amp1').value = 1.0;
                document.getElementById('freq1').value = 50;
                document.getElementById('phase1').value = 0;

                document.getElementById('amp2').value = 0.33;
                document.getElementById('freq2').value = 150;
                document.getElementById('phase2').value = 0;

                document.getElementById('amp3').value = 0.20;
                document.getElementById('freq3').value = 250;
                document.getElementById('phase3').value = 0;

                updateCustomSignal();
            }, 300);
        }

        function setupExercise2() {
            // Passa alla sezione laboratorio
            document.querySelector('[data-section="laboratorio"]').click();

            // Genera un segnale a 100 Hz con disturbo a 50 Hz e rumore
            setTimeout(() => {
                const signal = [];
                for (let i = 0; i < numSamples; i++) {
                    const t = i / sampleRate;
                    const useful = 1.0 * Math.sin(2 * Math.PI * 100 * t);
                    const disturbance = 0.3 * Math.sin(2 * Math.PI * 50 * t);
                    const noise = 0.1 * (Math.random() * 2 - 1);
                    signal.push(useful + disturbance + noise);
                }
                updatePlots(signal);
            }, 300);
        }

        function setupExercise3() {
            // Passa alla sezione laboratorio
            document.querySelector('[data-section="laboratorio"]').click();

            // Genera un'onda quadra
            setTimeout(() => {
                document.getElementById('signalFreqInput').value = 100;
                document.querySelector('input[name="signalType"][value="square"]').checked = true;
                generatePredefinedSignal();
            }, 300);
        }

        function setupExercise4() {
            // Passa alla sezione laboratorio
            document.querySelector('[data-section="laboratorio"]').click();

            // Configura per mostrare effetti del windowing
            setTimeout(() => {
                // Attiva campionamento sincrono inizialmente
                document.getElementById('syncSamplingCheck').checked = true;
                syncSampling = true;

                // Imposta una sinusoide a 100 Hz
                document.getElementById('signalFreqInput').value = 100;
                document.querySelector('input[name="signalType"][value="sine"]').checked = true;

                // Genera il segnale
                generatePredefinedSignal();

                // Mostra il modale informativo invece dell'alert
                openModal('modalExercise4');
            }, 300);
        }

        function setupExercise5() {
            // Passa alla sezione laboratorio
            document.querySelector('[data-section="laboratorio"]').click();

            // Configura per confrontare le finestre
            setTimeout(() => {
                // Disattiva campionamento sincrono per creare leakage intenzionale
                document.getElementById('syncSamplingCheck').checked = false;
                syncSampling = false;

                // Imposta parametri specifici per vedere bene il leakage
                document.getElementById('sampleRateInput').value = 8000;
                document.getElementById('numSamplesInput').value = 950; // Volutamente non sincrono

                sampleRate = 8000;
                numSamples = 950;

                // Genera una sinusoide pura a 100 Hz
                document.getElementById('signalFreqInput').value = 100;
                document.querySelector('input[name="signalType"][value="sine"]').checked = true;

                generatePredefinedSignal();

                // Resetta la finestra a rettangolare
                document.getElementById('windowType').value = 'rectangular';

                // Mostra il modale informativo invece dell'alert
                openModal('modalExercise5');
            }, 300);
        }

        // ============================================
        // INIZIALIZZAZIONE
        // ============================================

        window.addEventListener('load', () => {
            // Aggiorna lo stato del campionamento
            updateSamplingStatus();

            // Genera un segnale sinusoidale di default con delay maggiore
            // per assicurarsi che il CSS e il layout siano completamente applicati
            setTimeout(() => {
                const defaultSignal = generateSine(100, 1, numSamples, sampleRate);
                updatePlots(defaultSignal);
            }, 300);

            // Inizializza il costruttore custom con i valori attuali
            updateCustomSignal();

            // Inizializza i calcolatori
            calcFreqToPeriod();
            calcPeriodToFreq();
        });

        // ============================================
        // FUNZIONI CALCOLATORI INTERATTIVI
        // ============================================

        /**
         * Calcolatore 1: Risoluzione in Frequenza
         */
        function calculateResolution() {
            const fs = parseFloat(document.getElementById('calc1_fs').value);
            const n = parseInt(document.getElementById('calc1_n').value);

            if (isNaN(fs) || isNaN(n) || fs <= 0 || n <= 0) {
                alert('Inserisci valori validi per frequenza di campionamento e numero di campioni!');
                return;
            }

            // Calcoli
            const deltaF = fs / n;
            const duration = n / fs;
            const nyquist = fs / 2;

            // Mostra risultati
            document.getElementById('calc1_result').style.display = 'block';
            document.getElementById('calc1_delta_f').textContent = deltaF.toFixed(3) + ' Hz';
            document.getElementById('calc1_duration').textContent = duration.toFixed(6) + ' s (' + (duration * 1000).toFixed(3) + ' ms)';
            document.getElementById('calc1_nyquist').textContent = nyquist.toFixed(1) + ' Hz';

            // Interpretazione
            let interpretation = '';
            if (deltaF < 1) {
                interpretation = 'Ottima risoluzione! Puoi distinguere frequenze molto vicine tra loro.';
            } else if (deltaF < 10) {
                interpretation = 'Buona risoluzione per la maggior parte delle applicazioni.';
            } else if (deltaF < 100) {
                interpretation = 'Risoluzione moderata. Considera di aumentare N per maggiore precisione.';
            } else {
                interpretation = 'Risoluzione bassa. Aumenta N o riduci Fs per migliorare la risoluzione.';
            }

            interpretation += ` Con questi parametri puoi distinguere due frequenze separate di almeno ${deltaF.toFixed(3)} Hz.`;
            document.getElementById('calc1_interpretation').textContent = interpretation;
        }

        /**
         * Calcolatore 2a: Da Frequenza a Periodo
         */
        function calcFreqToPeriod() {
            const freq = parseFloat(document.getElementById('calc2_freq').value);

            if (isNaN(freq) || freq <= 0) {
                document.getElementById('calc2_period_result').textContent = '---';
                document.getElementById('calc2_period_ms').textContent = '---';
                return;
            }

            const period = 1 / freq;
            const periodMs = period * 1000;

            document.getElementById('calc2_period_result').textContent = period.toExponential(3) + ' s';
            document.getElementById('calc2_period_ms').textContent = periodMs.toFixed(6);
        }

        /**
         * Calcolatore 2b: Da Periodo a Frequenza
         */
        function calcPeriodToFreq() {
            const period = parseFloat(document.getElementById('calc2_period').value);

            if (isNaN(period) || period <= 0) {
                document.getElementById('calc2_freq_result').textContent = '---';
                document.getElementById('calc2_freq_khz').textContent = '---';
                return;
            }

            const freq = 1 / period;
            const freqKhz = freq / 1000;

            document.getElementById('calc2_freq_result').textContent = freq.toFixed(3) + ' Hz';
            document.getElementById('calc2_freq_khz').textContent = freqKhz.toFixed(6);
        }

        /**
         * Calcolatore 3: Componente Sinusoidale
         */
        function calculateSineWave() {
            const amp = parseFloat(document.getElementById('calc3_amp').value);
            const freq = parseFloat(document.getElementById('calc3_freq').value);
            const phaseDeg = parseFloat(document.getElementById('calc3_phase').value);
            const time = parseFloat(document.getElementById('calc3_time').value);

            if (isNaN(amp) || isNaN(freq) || isNaN(phaseDeg) || isNaN(time)) {
                alert('Inserisci valori validi per tutti i parametri!');
                return;
            }

            // Converti fase in radianti
            const phaseRad = phaseDeg * Math.PI / 180;

            // Calcola il valore
            const value = amp * Math.sin(2 * Math.PI * freq * time + phaseRad);

            // Mostra risultati
            document.getElementById('calc3_result').style.display = 'block';

            // Formula espansa
            const formulaText = `y = ${amp.toFixed(2)} √ó sin(2œÄ √ó ${freq} √ó ${time} + ${phaseDeg}¬∞)`;
            document.getElementById('calc3_formula').textContent = formulaText;

            // Valore
            document.getElementById('calc3_value').textContent = value.toFixed(6);

            // Informazioni aggiuntive
            const period = 1 / freq;
            const numPeriods = time / period;
            const phaseInfo = phaseDeg !== 0 ? ` con uno spostamento di fase di ${phaseDeg}¬∞ (${phaseRad.toFixed(4)} rad)` : '';

            let info = `Al tempo t = ${time} s, siamo a ${numPeriods.toFixed(3)} periodi dalla partenza${phaseInfo}. `;

            if (Math.abs(value) < 0.1) {
                info += 'Il valore √® vicino allo zero (attraversamento).';
            } else if (Math.abs(value) > 0.9 * amp) {
                info += 'Il valore √® vicino al picco (massimo o minimo).';
            } else {
                info += 'Il valore √® in una fase intermedia dell\'oscillazione.';
            }

            document.getElementById('calc3_info').textContent = info;
        }

        /**
         * Calcolatore 4: Campioni Ottimali per Campionamento Sincrono
         */
        function calculateOptimalSamples() {
            const signalFreq = parseFloat(document.getElementById('calc4_freq').value);
            const fs = parseFloat(document.getElementById('calc4_fs').value);
            const desiredPeriods = parseInt(document.getElementById('calc4_periods').value);

            if (isNaN(signalFreq) || isNaN(fs) || isNaN(desiredPeriods) ||
                signalFreq <= 0 || fs <= 0 || desiredPeriods <= 0) {
                alert('Inserisci valori validi per tutti i parametri!');
                return;
            }

            // Verifica Nyquist
            const nyquist = fs / 2;
            if (signalFreq > nyquist) {
                alert(`‚ö†Ô∏è ATTENZIONE: La frequenza del segnale (${signalFreq} Hz) supera la frequenza di Nyquist (${nyquist} Hz)!\nAumenta la frequenza di campionamento ad almeno ${(signalFreq * 2.5).toFixed(0)} Hz.`);
                return;
            }

            // Calcoli
            const samplesPerPeriod = fs / signalFreq;
            const exactSamples = Math.round(desiredPeriods * samplesPerPeriod);

            // Trova la potenza di 2 pi√π vicina
            const pow2 = Math.pow(2, Math.round(Math.log2(exactSamples)));
            const periodsWithPow2 = pow2 / samplesPerPeriod;

            // Mostra risultati
            document.getElementById('calc4_result').style.display = 'block';
            document.getElementById('calc4_spp').textContent = samplesPerPeriod.toFixed(2);
            document.getElementById('calc4_exact').textContent = exactSamples;
            document.getElementById('calc4_pow2').textContent = `${pow2} (2^${Math.log2(pow2)})`;
            document.getElementById('calc4_periods_pow2').textContent = periodsWithPow2.toFixed(3);

            // Valuta se ci sar√† windowing
            const isInteger = Math.abs(periodsWithPow2 - Math.round(periodsWithPow2)) < 0.05;
            const warningDiv = document.getElementById('calc4_warning');

            if (isInteger) {
                warningDiv.style.display = 'block';
                warningDiv.style.background = '#d4edda';
                warningDiv.style.borderLeft = '4px solid #28a745';
                warningDiv.style.color = '#155724';
                warningDiv.innerHTML = `<strong>‚úì Perfetto!</strong> Con ${pow2} campioni catturi quasi esattamente ${Math.round(periodsWithPow2)} periodi. Nessun windowing significativo!`;
            } else {
                warningDiv.style.display = 'block';
                warningDiv.style.background = '#fff3cd';
                warningDiv.style.borderLeft = '4px solid #f0ad4e';
                warningDiv.style.color = '#856404';
                const fractionalPart = (periodsWithPow2 - Math.floor(periodsWithPow2)).toFixed(2);
                warningDiv.innerHTML = `<strong>‚ö† Attenzione!</strong> Con ${pow2} campioni catturi ${periodsWithPow2.toFixed(2)} periodi (parte frazionaria: ${fractionalPart}). Ci sar√† un leggero leakage spettrale.`;
            }

            // Raccomandazione
            let recommendation = '';
            if (exactSamples === pow2) {
                recommendation = `Usa esattamente ${exactSamples} campioni per campionamento sincrono perfetto!`;
            } else if (isInteger) {
                recommendation = `Usa ${pow2} campioni (potenza di 2) per ottime prestazioni FFT con windowing minimo.`;
            } else {
                recommendation = `Opzione 1: Usa ${exactSamples} campioni (sincrono perfetto ma FFT pi√π lenta). Opzione 2: Usa ${pow2} campioni (FFT veloce ma con leggero windowing).`;
            }

            document.getElementById('calc4_recommendation').textContent = recommendation;
        }

        // ============================================
        // GESTIONE DEL RESIZE
        // ============================================

        // Gestione del resize della finestra per grafici responsive
        let resizeTimer;
        window.addEventListener('resize', () => {
            // Debounce: aspetta che l'utente finisca di ridimensionare
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                // Ridisegna i grafici solo se esistono
                if (currentTimeData.length > 0) {
                    Plotly.Plots.resize('timeChart');
                    Plotly.Plots.resize('freqChart');
                }
            }, 250);
        });
    </script>
</body>

</html>