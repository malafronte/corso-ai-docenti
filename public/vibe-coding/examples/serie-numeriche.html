<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Esploratore di Serie Matematiche</title>

    <!-- CDN Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.1/math.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    <!--
    STRATEGIA DI IMPLEMENTAZIONE:
    
    1. STRUTTURA HTML:
       - #app-container: wrapper principale con layout grid
       - #controls: pannello input/esempi/sliders (sinistra/alto)
       - #charts: area visualizzazione grafici (centro)
       - #analysis: pannello risultati/test convergenza (destra/basso)
    
    2. LOGICA JS - FUNZIONI CHIAVE:
       - init(): inizializza l'app, carica preset, configura eventi
       - parseExpression(expr): valida e compila espressione con Math.js
       - calculateSeriesData(N, x): calcola termini a_n e somme parziali S_N
       - updateCharts(): aggiorna grafici Chart.js con nuovi dati
       - runConvergenceTests(): esegue criteri rapporto/radice/condizione necessaria
       - exportCSV(): genera e scarica dati come CSV
       - renderMath(): renderizza tutte le formule KaTeX
    
    3. GESTIONE STATO:
       - state object globale: { expression, compiledNode, N, x, isPowerSeries, preset }
       - Aggiornamento reattivo: ogni modifica di stato ‚Üí ricalcolo + aggiornamento UI
    -->

    <style>
        :root {
            /* Design System Colors - Light Mode */
            --color-background: #f8f9fa;
            --color-surface: #ffffff;
            --color-text: #1a202c;
            --color-text-secondary: #718096;
            --color-primary: #2196F3;
            --color-primary-hover: #1976D2;
            --color-border: #e2e8f0;
            --color-card-border: #cbd5e0;
            --color-success: #4caf50;
            --color-error: #f44336;
            --color-warning: #ff9800;
            --color-secondary: #f1f5f9;

            /* Typography */
            --font-family-base: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            --font-family-mono: "Courier New", monospace;

            /* Spacing */
            --space-8: 8px;
            --space-12: 12px;
            --space-16: 16px;
            --space-20: 20px;
            --space-24: 24px;

            /* Border Radius */
            --radius-base: 8px;
            --radius-lg: 12px;

            /* Shadows */
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family-base);
            background-color: var(--color-background);
            color: var(--color-text);
            line-height: 1.6;
            padding: var(--space-20);
        }

        h1,
        h2,
        h3 {
            margin-bottom: var(--space-16);
            font-weight: 600;
            color: var(--color-text);
        }

        h1 {
            font-size: 28px;
        }

        h2 {
            font-size: 20px;
        }

        h3 {
            font-size: 16px;
        }

        #app-container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: var(--space-20);
            grid-template-areas:
                "header header header"
                "controls charts analysis";
        }

        @media (max-width: 1200px) {
            #app-container {
                grid-template-columns: 1fr 1fr;
                grid-template-areas:
                    "header header"
                    "controls charts"
                    "analysis analysis";
            }
        }

        @media (max-width: 768px) {
            #app-container {
                grid-template-columns: 1fr;
                grid-template-areas:
                    "header"
                    "controls"
                    "charts"
                    "analysis";
            }
        }

        header {
            grid-area: header;
            background: var(--color-surface);
            padding: var(--space-24);
            border-radius: var(--radius-lg);
            border: 1px solid var(--color-card-border);
            box-shadow: var(--shadow-sm);
        }

        .section {
            background: var(--color-surface);
            padding: var(--space-20);
            border-radius: var(--radius-lg);
            border: 1px solid var(--color-card-border);
            box-shadow: var(--shadow-sm);
        }

        #controls {
            grid-area: controls;
        }

        #charts {
            grid-area: charts;
        }

        #analysis {
            grid-area: analysis;
        }

        .form-group {
            margin-bottom: var(--space-16);
        }

        label {
            display: block;
            font-weight: 500;
            margin-bottom: var(--space-8);
            font-size: 14px;
        }

        input[type="text"],
        input[type="number"],
        select {
            width: 100%;
            padding: var(--space-12);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-base);
            background: var(--color-background);
            color: var(--color-text);
            font-size: 14px;
            font-family: var(--font-family-mono);
        }

        input:focus,
        select:focus {
            outline: 2px solid var(--color-primary);
            border-color: var(--color-primary);
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            gap: var(--space-8);
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--color-secondary);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--color-primary);
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--color-primary);
            cursor: pointer;
            border: none;
        }

        .btn {
            padding: var(--space-12) var(--space-20);
            background: var(--color-primary);
            color: white;
            border: none;
            border-radius: var(--radius-base);
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.2s;
            width: 100%;
        }

        .btn:hover {
            background: var(--color-primary-hover);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: var(--color-secondary);
            color: var(--color-text);
        }

        .btn-secondary:hover {
            background: #e2e8f0;
        }

        .btn-spacing {
            margin-top: var(--space-12);
        }

        .hidden {
            display: none;
        }

        .section-divider {
            margin: var(--space-20) 0;
            padding: var(--space-16);
            background: var(--color-secondary);
            border-radius: var(--radius-base);
            border-left: 4px solid var(--color-primary);
        }

        .section-divider h3 {
            margin: 0 0 var(--space-8) 0;
            color: var(--color-primary);
            font-size: 16px;
        }

        .section-divider p {
            margin: 0;
            font-size: 13px;
            color: var(--color-text-secondary);
        }

        .chart-wrapper {
            margin-bottom: var(--space-24);
            position: relative;
            height: 300px;
        }

        .alert {
            padding: var(--space-16);
            border-radius: var(--radius-base);
            margin-bottom: var(--space-16);
            font-weight: 500;
        }

        .alert-success {
            background: #e8f5e9;
            border: 1px solid #4caf50;
            color: #2e7d32;
        }

        .alert-error {
            background: #ffebee;
            border: 1px solid #f44336;
            color: #c62828;
        }

        .alert-warning {
            background: #fff3e0;
            border: 1px solid #ff9800;
            color: #e65100;
        }

        .alert-info {
            background: #e3f2fd;
            border: 1px solid #2196F3;
            color: #1565c0;
        }

        .result-item {
            padding: var(--space-12);
            background: var(--color-background);
            border-radius: var(--radius-base);
            margin-bottom: var(--space-12);
            border: 1px solid var(--color-border);
        }

        .result-label {
            font-size: 12px;
            color: var(--color-text-secondary);
            margin-bottom: 4px;
        }

        .result-value {
            font-size: 16px;
            font-family: var(--font-family-mono);
            font-weight: 500;
        }

        .help-text {
            font-size: 12px;
            color: var(--color-text-secondary);
            margin-top: 4px;
        }

        .math-display {
            overflow-x: auto;
            padding: var(--space-8) 0;
        }

        #x-control-group {
            display: none;
        }

        #x-control-group.visible {
            display: block;
        }

        .instruction-box {
            background: #e3f2fd;
            padding: var(--space-16);
            border-radius: var(--radius-base);
            margin-bottom: var(--space-20);
            font-size: 14px;
            line-height: 1.6;
            border-left: 4px solid var(--color-primary);
        }

        .series-badges {
            margin-top: 8px;
        }

        .katex {
            font-size: 1.1em;
        }

        #didactic-explanation {
            margin-top: var(--space-16);
        }

        #explanation-content {
            max-height: 600px;
            overflow-y: auto;
        }

        #explanation-content h4 {
            margin-top: var(--space-16);
            margin-bottom: var(--space-12);
            font-size: 16px;
        }

        #explanation-content ul {
            margin-left: var(--space-20);
            margin-top: var(--space-8);
            margin-bottom: var(--space-8);
        }

        #explanation-content li {
            margin-bottom: var(--space-8);
        }

        #explanation-content hr {
            margin: var(--space-16) 0;
            border: none;
            border-top: 1px solid var(--color-border);
        }

        #explanation-content p {
            margin-bottom: var(--space-12);
        }

        /* Stili per i modali */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            overflow: auto;
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .modal-content {
            background-color: var(--color-surface);
            margin: var(--space-20);
            padding: 0;
            border-radius: var(--radius-lg);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            max-width: 800px;
            width: 90%;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            animation: slideIn 0.3s;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            padding: var(--space-24);
            border-bottom: 2px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-hover) 100%);
            color: white;
            border-radius: var(--radius-lg) var(--radius-lg) 0 0;
        }

        .modal-header h2 {
            margin: 0;
            color: white;
            font-size: 22px;
        }

        .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 32px;
            font-weight: 300;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            line-height: 1;
            transition: transform 0.2s;
        }

        .close-btn:hover {
            transform: rotate(90deg);
        }

        .modal-body {
            padding: var(--space-24);
            overflow-y: auto;
            flex: 1;
        }

        .modal-body h3 {
            color: var(--color-primary);
            margin-top: var(--space-24);
            margin-bottom: var(--space-12);
            font-size: 18px;
            border-bottom: 2px solid var(--color-primary);
            padding-bottom: var(--space-8);
        }

        .modal-body h3:first-child {
            margin-top: 0;
        }

        .modal-body h4 {
            color: var(--color-text);
            margin-top: var(--space-16);
            margin-bottom: var(--space-8);
            font-size: 16px;
        }

        .modal-body p {
            margin-bottom: var(--space-12);
            line-height: 1.7;
        }

        .modal-body ul,
        .modal-body ol {
            margin-left: var(--space-24);
            margin-bottom: var(--space-16);
        }

        .modal-body li {
            margin-bottom: var(--space-8);
            line-height: 1.6;
        }

        .modal-body .formula-box {
            background: var(--color-secondary);
            padding: var(--space-16);
            border-radius: var(--radius-base);
            margin: var(--space-16) 0;
            border-left: 4px solid var(--color-primary);
        }

        .modal-body .theorem-box {
            background: #e8f5e9;
            padding: var(--space-16);
            border-radius: var(--radius-base);
            margin: var(--space-16) 0;
            border-left: 4px solid #4caf50;
        }

        .modal-body .example-box {
            background: #fff3e0;
            padding: var(--space-16);
            border-radius: var(--radius-base);
            margin: var(--space-16) 0;
            border-left: 4px solid #ff9800;
        }

        .btn-info {
            background: transparent;
            border: 2px solid var(--color-primary);
            color: var(--color-primary);
            padding: var(--space-8) var(--space-16);
            font-size: 13px;
            border-radius: var(--radius-base);
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: var(--space-8);
        }

        .btn-info:hover {
            background: var(--color-primary);
            color: white;
        }

        .theory-buttons {
            display: flex;
            gap: var(--space-12);
            margin-bottom: var(--space-16);
            flex-wrap: wrap;
        }

        /* Badges UX */
        .badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 999px;
            font-size: 12px;
            font-weight: 600;
            border: 1px solid var(--color-border);
            background: var(--color-background);
            color: var(--color-text);
        }

        .badge+.badge {
            margin-left: 8px;
        }

        .badge-info {
            border-color: #90caf9;
            color: #1565c0;
            background: #e3f2fd;
        }

        .badge-success {
            border-color: #a5d6a7;
            color: #1b5e20;
            background: #e8f5e9;
        }

        .badge-warning {
            border-color: #ffcc80;
            color: #e65100;
            background: #fff3e0;
        }

        .badge-error {
            border-color: #ef9a9a;
            color: #b71c1c;
            background: #ffebee;
        }
    </style>
</head>

<body>
    <div id="app-container">
        <header>
            <h1>Esploratore di Serie Matematiche</h1>
            <div class="instruction-box">
                <p>
                    Strumento interattivo per l'analisi di <strong>serie numeriche</strong> e <strong>serie di
                        potenze</strong>.
                    Inserisci il termine generale <span class="math">a_n</span> (con variabile <code>n</code>)
                    oppure carica un esempio predefinito. Per serie di potenze, usa anche la variabile <code>x</code>.
                </p>
            </div>
            <div class="theory-buttons">
                <button class="btn-info" id="open-series-modal">üìö Teoria Serie Numeriche</button>
                <button class="btn-info" id="open-taylor-modal">üìê Teoria Serie di Taylor</button>
            </div>
        </header>

        <section id="controls" class="section">
            <h2>Pannello di Controllo</h2>

            <div class="section-divider">
                <h3>üìä Serie Numeriche</h3>
                <p>Serie del tipo ‚àë a‚Çô (senza dipendenza da x)</p>
            </div>

            <div class="form-group">
                <label for="numeric-preset-select">Esempi Serie Numeriche:</label>
                <select id="numeric-preset-select" aria-label="Seleziona serie numerica">
                    <option value="">-- Seleziona un esempio --</option>
                    <option value="1/n^2">‚àë 1/n¬≤ (Serie armonica generalizzata, p=2)</option>
                    <option value="1/n">‚àë 1/n (Serie armonica - divergente)</option>
                    <option value="1/factorial(n)">‚àë 1/n! (Converge a e-1)</option>
                    <option value="(-1)^n / n">‚àë (-1)‚Åø/n (Serie armonica alternata)</option>
                    <option value="(1/2)^n">‚àë (1/2)‚Åø (Serie geometrica)</option>
                </select>
            </div>

            <div class="section-divider">
                <h3>üìà Serie di Taylor / Potenze</h3>
                <p>Serie del tipo ‚àë a‚Çô¬∑x‚Åø (con dipendenza da x)</p>
            </div>

            <div class="form-group">
                <label for="power-preset-select">Esempi Serie di Potenze:</label>
                <select id="power-preset-select" aria-label="Seleziona serie di potenze">
                    <option value="">-- Seleziona un esempio --</option>
                    <option value="x^n / factorial(n)">‚àë x‚Åø/n! ‚Üí eÀ£</option>
                    <option value="(-1)^n * x^(2*n+1) / factorial(2*n+1)">‚àë (-1)‚Åø¬∑x^(2n+1)/(2n+1)! ‚Üí sin(x)</option>
                    <option value="(-1)^n * x^(2*n) / factorial(2*n)">‚àë (-1)‚Åø¬∑x^(2n)/(2n)! ‚Üí cos(x)</option>
                    <option value="(-1)^n * x^(n+1) / (n+1)">‚àë (-1)‚Åø¬∑x^(n+1)/(n+1) ‚Üí ln(1+x)</option>
                </select>
            </div>

            <div class="section-divider">
                <h3>üß™ Analisi Personalizzata: Serie Numeriche e di Taylor</h3>
                <p>Definisci il termine generale <span class="math">a_n</span> per analizzare la tua serie. Per le serie
                    di potenze usa anche la variabile <code>x</code>.</p>
            </div>

            <div class="form-group">
                <label for="expression-input">
                    Termine Generale a<sub>n</sub>:
                    <span class="help-text">Usa 'n' per l'indice, 'x' per serie di potenze</span>
                </label>
                <input type="text" id="expression-input" placeholder="Es: 1/n^2  oppure  x^n / factorial(n)"
                    value="1/n^2" aria-label="Termine generale della serie">
                <div id="series-badges" class="series-badges">
                    <span id="type-badge" class="badge badge-info">Tipo rilevato: ‚Äî</span>
                    <span id="radius-badge" class="badge badge-info hidden">R ‚âà ‚Äî</span>
                    <span id="x-status-badge" class="badge badge-info hidden">x=1: ‚Äî</span>
                </div>
                <span class="help-text">I risultati si aggiornano automaticamente</span>
            </div>

            <div class="form-group">
                <div class="slider-container">
                    <div class="slider-header">
                        <label for="n-slider">Numero Termini N:</label>
                        <span id="n-value">50</span>
                    </div>
                    <input type="range" id="n-slider" min="5" max="200" value="50" aria-label="Numero di termini">
                </div>
            </div>

            <div id="x-control-group" class="form-group">
                <div class="slider-container">
                    <div class="slider-header">
                        <label for="x-slider">Valore di x:</label>
                        <span id="x-value">1.0</span>
                    </div>
                    <input type="range" id="x-slider" min="-10" max="10" step="0.1" value="1" aria-label="Valore di x">
                    <input type="number" id="x-input" step="0.1" min="-10" max="10" value="1" placeholder="Valore x"
                        aria-label="Valore numerico di x">
                </div>
            </div>

            <button id="export-btn" class="btn btn-secondary btn-spacing">üì• Esporta CSV</button>
        </section>

        <section id="charts" class="section">
            <h2>Visualizzazione</h2>

            <div class="chart-wrapper">
                <h3>Somme Parziali <span class="math">S_N</span></h3>
                <canvas id="partial-sums-chart"></canvas>
            </div>

            <div id="power-series-chart-wrapper" class="chart-wrapper hidden">
                <h3>Confronto Funzione vs Approssimazione</h3>
                <canvas id="power-series-chart"></canvas>
            </div>
        </section>

        <section id="analysis" class="section">
            <h2>Analisi della Convergenza</h2>

            <div id="convergence-indicator"></div>

            <div id="didactic-explanation">
                <h3>Spiegazione Didattica</h3>
                <div id="explanation-content" class="alert alert-info">
                    <p>Seleziona una serie per vedere la spiegazione del tipo di serie e dei criteri di convergenza
                        applicabili.</p>
                </div>
            </div>

            <div id="test-results">
                <h3>Test di Convergenza</h3>
                <div id="test-output"></div>
            </div>

            <div id="numerical-results">
                <h3>Risultati Numerici</h3>
                <div class="result-item">
                    <div class="result-label">Somma Parziale <span class="math">S_N</span></div>
                    <div class="result-value" id="sum-value">-</div>
                </div>
                <div class="result-item">
                    <div class="result-label">Ultimo Termine <span class="math">a_N</span></div>
                    <div class="result-value" id="last-term-value">-</div>
                </div>
                <div class="result-item">
                    <div class="result-label">Stima Errore <span class="math">R_N</span></div>
                    <div class="result-value" id="error-estimate">-</div>
                </div>
            </div>
        </section>
    </div>

    <script>
        // ============================================
        // STATO GLOBALE DELL'APPLICAZIONE
        // ============================================
        const state = {
            expression: '1/n^2',
            compiledNode: null,
            N: 50,
            x: 1,
            isPowerSeries: false,
            preset: '',
            radiusEstimate: null,
            presetFunctions: {
                'x^n / factorial(n)': { func: Math.exp, name: 'e^x' },
                '(-1)^n * x^(2*n+1) / factorial(2*n+1)': { func: Math.sin, name: 'sin(x)' },
                '(-1)^n * x^(2*n) / factorial(2*n)': { func: Math.cos, name: 'cos(x)' },
                '(-1)^n * x^(n+1) / (n+1)': { func: (x) => Math.log(1 + x), name: 'ln(1+x)' }
            }
        };

        // ============================================
        // VARIABILI GRAFICI CHART.JS
        // ============================================
        let partialSumsChart = null;
        let powerSeriesChart = null;

        // ============================================
        // INIZIALIZZAZIONE
        // ============================================
        function init() {
            setupEventListeners();
            parseExpression(state.expression);
            calculate();
            renderMath();
            updateTypeBadges();
        }

        function setupEventListeners() {
            document.getElementById('numeric-preset-select').addEventListener('change', handleNumericPresetChange);
            document.getElementById('power-preset-select').addEventListener('change', handlePowerPresetChange);
            document.getElementById('expression-input').addEventListener('input', handleExpressionChange);
            document.getElementById('n-slider').addEventListener('input', handleNSliderChange);
            document.getElementById('x-slider').addEventListener('input', handleXSliderChange);
            document.getElementById('x-input').addEventListener('input', handleXInputChange);
            document.getElementById('export-btn').addEventListener('click', exportCSV);
        }

        // ============================================
        // GESTIONE EVENTI
        // ============================================
        function handleNumericPresetChange(e) {
            const value = e.target.value;
            if (value) {
                // Resetta l'altro dropdown
                document.getElementById('power-preset-select').value = '';
                state.preset = '';
                state.expression = value;
                document.getElementById('expression-input').value = value;
                parseExpression(value);
                calculate();
            }
        }

        function handlePowerPresetChange(e) {
            const value = e.target.value;
            if (value) {
                // Resetta l'altro dropdown
                document.getElementById('numeric-preset-select').value = '';
                state.preset = value;
                state.expression = value;
                document.getElementById('expression-input').value = value;
                parseExpression(value);
                calculate();
            }
        }

        function handleExpressionChange(e) {
            state.expression = e.target.value;
            state.preset = '';
            // Resetta entrambi i dropdown
            document.getElementById('numeric-preset-select').value = '';
            document.getElementById('power-preset-select').value = '';
            if (parseExpression(e.target.value)) {
                calculate();
            }
        }

        function handleNSliderChange(e) {
            state.N = parseInt(e.target.value);
            document.getElementById('n-value').textContent = state.N;
            calculate();
        }

        function handleXSliderChange(e) {
            state.x = parseFloat(e.target.value);
            document.getElementById('x-value').textContent = state.x.toFixed(1);
            document.getElementById('x-input').value = state.x;
            calculate();
            updateXStatusBadge();
        }

        function handleXInputChange(e) {
            const value = parseFloat(e.target.value);
            if (!isNaN(value)) {
                state.x = value;
                document.getElementById('x-value').textContent = value.toFixed(1);
                document.getElementById('x-slider').value = value;
                calculate();
                updateXStatusBadge();
            }
        }

        // ============================================
        // PARSING ESPRESSIONI CON MATH.JS
        // ============================================
        function parseExpression(expr) {
            try {
                const node = math.parse(expr);
                state.compiledNode = node.compile();

                // Verifica se contiene 'x' (serie di potenze)
                const exprStr = expr.toLowerCase();
                state.isPowerSeries = exprStr.includes('x');

                // Mostra/nascondi controllo x
                const xControl = document.getElementById('x-control-group');
                if (state.isPowerSeries) {
                    xControl.classList.add('visible');
                } else {
                    xControl.classList.remove('visible');
                }

                // Aggiorna badge tipo e (se potenze) stima raggio di convergenza
                updateTypeBadges();
                if (state.isPowerSeries) {
                    // Stima asincrona per non bloccare UI
                    setTimeout(estimatePowerSeriesRadius, 0);
                }

                // Nascondi messaggi errore precedenti
                const indicator = document.getElementById('convergence-indicator');
                indicator.innerHTML = '';

                return true;
            } catch (error) {
                const indicator = document.getElementById('convergence-indicator');
                indicator.innerHTML = `
                    <div class="alert alert-error">
                        <strong>Errore di Parsing:</strong> ${error.message}
                    </div>
                `;
                return false;
            }
        }

        // ============================================
        // CALCOLO DATI SERIE
        // ============================================
        function calculateSeriesData(N, x) {
            const terms = [];
            const partialSums = [];
            let sum = 0;

            // Determina l'indice di partenza: 0 per serie di potenze, 1 per serie numeriche
            const startIndex = state.isPowerSeries ? 0 : 1;

            for (let n = startIndex; n <= N; n++) {
                try {
                    const scope = { n: n };
                    if (state.isPowerSeries) {
                        scope.x = x;
                    }

                    const term = state.compiledNode.evaluate(scope);

                    // Gestione valori infiniti o NaN
                    if (!isFinite(term) || isNaN(term)) {
                        throw new Error(`Termine a_${n} non finito o NaN`);
                    }

                    terms.push(term);
                    sum += term;
                    partialSums.push(sum);
                } catch (error) {
                    throw new Error(`Errore nel calcolo di a_${n}: ${error.message}`);
                }
            }

            return { terms, partialSums };
        }

        // ============================================
        // FUNZIONE PRINCIPALE DI CALCOLO
        // ============================================
        function calculate() {
            if (!state.compiledNode) {
                return;
            }

            try {
                const { terms, partialSums } = calculateSeriesData(state.N, state.x);

                // Aggiorna risultati numerici
                updateNumericalResults(terms, partialSums);

                // Aggiorna grafici
                updatePartialSumsChart(partialSums);

                // Se serie di potenze, aggiorna grafico confronto
                if (state.isPowerSeries && state.presetFunctions[state.preset]) {
                    updatePowerSeriesChart(state.N, state.preset);
                    document.getElementById('power-series-chart-wrapper').style.display = 'block';
                } else {
                    document.getElementById('power-series-chart-wrapper').style.display = 'none';
                }

                // Esegui test convergenza
                runConvergenceTests(terms, partialSums);

            } catch (error) {
                const indicator = document.getElementById('convergence-indicator');
                indicator.innerHTML = `
                    <div class="alert alert-error">
                        <strong>Errore di Calcolo:</strong> ${error.message}
                    </div>
                `;
            }
        }

        // ============================================
        // AGGIORNAMENTO RISULTATI NUMERICI
        // ============================================
        function updateNumericalResults(terms, partialSums) {
            const lastSum = partialSums[partialSums.length - 1];
            const lastTerm = terms[terms.length - 1];

            document.getElementById('sum-value').textContent = formatNumber(lastSum);
            document.getElementById('last-term-value').textContent = formatNumber(lastTerm);

            // Stima errore (per serie alternate)
            const isAlternating = checkAlternating(terms);
            if (isAlternating && terms.length < 100) {
                try {
                    const scope = { n: state.N + 1 };
                    if (state.isPowerSeries) scope.x = state.x;
                    const nextTerm = state.compiledNode.evaluate(scope);
                    document.getElementById('error-estimate').textContent =
                        `‚âà ${formatNumber(Math.abs(nextTerm))} (serie alternata)`;
                } catch {
                    document.getElementById('error-estimate').textContent = 'Non calcolabile';
                }
            } else {
                document.getElementById('error-estimate').textContent = 'Non banale';
            }
        }

        // ============================================
        // GRAFICO SOMME PARZIALI
        // ============================================
        function updatePartialSumsChart(partialSums) {
            const ctx = document.getElementById('partial-sums-chart').getContext('2d');

            if (partialSumsChart) {
                partialSumsChart.destroy();
            }

            const startIndex = state.isPowerSeries ? 0 : 1;
            const labels = Array.from({ length: partialSums.length }, (_, i) => i + startIndex); partialSumsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'S‚Çô',
                        data: partialSums,
                        borderColor: 'rgba(33, 128, 141, 1)',
                        backgroundColor: 'rgba(33, 128, 141, 0.1)',
                        tension: 0.1,
                        pointRadius: 2,
                        pointHoverRadius: 5
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            labels: { color: getComputedStyle(document.body).getPropertyValue('--color-text') }
                        },
                        tooltip: {
                            callbacks: {
                                label: (context) => `S‚Çç${context.label}‚Çé = ${formatNumber(context.parsed.y)}`
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'N', color: getComputedStyle(document.body).getPropertyValue('--color-text') },
                            ticks: { color: getComputedStyle(document.body).getPropertyValue('--color-text-secondary') },
                            grid: { color: 'rgba(94, 82, 64, 0.1)' }
                        },
                        y: {
                            title: { display: true, text: 'S‚Çô', color: getComputedStyle(document.body).getPropertyValue('--color-text') },
                            ticks: { color: getComputedStyle(document.body).getPropertyValue('--color-text-secondary') },
                            grid: { color: 'rgba(94, 82, 64, 0.1)' }
                        }
                    }
                }
            });
        }

        // ============================================
        // GRAFICO CONFRONTO SERIE DI POTENZE
        // ============================================
        function updatePowerSeriesChart(N, preset) {
            const presetInfo = state.presetFunctions[preset];
            if (!presetInfo) return;

            const ctx = document.getElementById('power-series-chart').getContext('2d');

            if (powerSeriesChart) {
                powerSeriesChart.destroy();
            }

            // Genera punti x
            const xPoints = [];
            const step = 0.1;
            const range = preset.includes('ln') ? { min: -0.9, max: 3 } : { min: -2 * Math.PI, max: 2 * Math.PI };

            for (let x = range.min; x <= range.max; x += step) {
                xPoints.push(x);
            }

            // Calcola funzione originale
            const originalValues = xPoints.map(x => {
                try {
                    return presetInfo.func(x);
                } catch {
                    return NaN;
                }
            });

            // Calcola approssimazione polinomiale
            const approxValues = xPoints.map(x => {
                try {
                    let sum = 0;
                    for (let n = 0; n <= N; n++) {
                        const scope = { n: n, x: x };
                        sum += state.compiledNode.evaluate(scope);
                    }
                    return sum;
                } catch {
                    return NaN;
                }
            });

            powerSeriesChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: xPoints.map(x => x.toFixed(2)),
                    datasets: [
                        {
                            label: presetInfo.name,
                            data: originalValues,
                            borderColor: 'rgba(192, 21, 47, 1)',
                            backgroundColor: 'rgba(192, 21, 47, 0.1)',
                            borderWidth: 2,
                            pointRadius: 0,
                            tension: 0.4
                        },
                        {
                            label: `P‚Çô(x) [N=${N}]`,
                            data: approxValues,
                            borderColor: 'rgba(33, 128, 141, 1)',
                            backgroundColor: 'rgba(33, 128, 141, 0.1)',
                            borderWidth: 2,
                            pointRadius: 0,
                            tension: 0.4,
                            borderDash: [5, 5]
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            labels: { color: getComputedStyle(document.body).getPropertyValue('--color-text') }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'x', color: getComputedStyle(document.body).getPropertyValue('--color-text') },
                            ticks: {
                                color: getComputedStyle(document.body).getPropertyValue('--color-text-secondary'),
                                maxTicksLimit: 10
                            },
                            grid: { color: 'rgba(94, 82, 64, 0.1)' }
                        },
                        y: {
                            title: { display: true, text: 'y', color: getComputedStyle(document.body).getPropertyValue('--color-text') },
                            ticks: { color: getComputedStyle(document.body).getPropertyValue('--color-text-secondary') },
                            grid: { color: 'rgba(94, 82, 64, 0.1)' }
                        }
                    }
                }
            });
        }

        // ============================================
        // TEST DI CONVERGENZA
        // ============================================
        function runConvergenceTests(terms, partialSums) {
            const results = [];
            let overallStatus = 'INCONCLUSIVO';
            let statusClass = 'alert-warning';
            let explanation = '';

            // Verifica se la serie √® alternata
            const isAlternating = checkAlternating(terms);

            // Test 1: Condizione necessaria (lim a_n = 0)
            const lastTerms = terms.slice(-10);
            const avgLastTerms = lastTerms.reduce((a, b) => a + Math.abs(b), 0) / lastTerms.length;

            // Per serie alternate, usa soglia pi√π permissiva e criterio di Leibniz
            const threshold = isAlternating ? 0.1 : 0.01;

            if (avgLastTerms > threshold) {
                overallStatus = 'DIVERGENTE';
                statusClass = 'alert-error';
                explanation = `La condizione necessaria $\\lim_{n \\to \\infty} a_n = 0$ non √® soddisfatta. Media ultimi 10 termini: ${formatNumber(avgLastTerms)}`;
                results.push({
                    test: 'Condizione Necessaria',
                    result: 'FALLITO',
                    value: `|a‚Çô| ‚âà ${formatNumber(avgLastTerms)} ‚â† 0`
                });
            } else {
                results.push({
                    test: 'Condizione Necessaria',
                    result: 'SODDISFATTO',
                    value: `|a‚Çô| ‚Üí 0`
                });

                // Test per serie alternata (Criterio di Leibniz)
                if (isAlternating) {
                    const absTerms = terms.map(Math.abs);
                    let isDecreasing = true;
                    for (let i = absTerms.length - 10; i < absTerms.length - 1; i++) {
                        if (i >= 0 && absTerms[i + 1] > absTerms[i] * 1.01) { // tolleranza 1%
                            isDecreasing = false;
                            break;
                        }
                    }

                    if (isDecreasing && avgLastTerms < 0.1) {
                        overallStatus = 'CONVERGENTE';
                        statusClass = 'alert-success';
                        explanation = `Criterio di Leibniz: serie alternata con termini decrescenti e $|a_n| \\to 0$`;
                        results.push({
                            test: 'Criterio di Leibniz',
                            result: 'CONVERGENTE',
                            value: 'Serie alternata a termini decrescenti'
                        });
                    } else {
                        results.push({
                            test: 'Criterio di Leibniz',
                            result: isDecreasing ? 'SODDISFATTO' : 'INCONCLUSIVO',
                            value: isDecreasing ? 'Termini decrescenti' : 'Termini non strettamente decrescenti'
                        });
                    }
                }

                // Test 2: Criterio del Rapporto (solo se non gi√† concluso)
                if (overallStatus === 'INCONCLUSIVO') {
                    try {
                        const ratios = [];
                        // Prendi i termini dalla met√† della serie per avere valori pi√π stabili
                        const startIdx = Math.max(10, Math.floor(terms.length / 2));
                        for (let i = startIdx; i < Math.min(terms.length - 1, startIdx + 20); i++) {
                            if (Math.abs(terms[i]) > 1e-100 && Math.abs(terms[i + 1]) > 1e-100) {
                                ratios.push(Math.abs(terms[i + 1] / terms[i]));
                            }
                        }

                        if (ratios.length > 0) {
                            const L = ratios.reduce((a, b) => a + b, 0) / ratios.length;
                            results.push({
                                test: 'Criterio del Rapporto',
                                result: L < 1 ? 'CONVERGENTE' : (L > 1 ? 'DIVERGENTE' : 'INCONCLUSIVO'),
                                value: `L ‚âà ${formatNumber(L)}`
                            });

                            if (L < 0.95) {
                                overallStatus = 'CONVERGENTE';
                                statusClass = 'alert-success';
                                explanation = `Criterio del Rapporto: $L \\approx ${formatNumber(L)} < 1$`;
                            } else if (L > 1.05) {
                                overallStatus = 'DIVERGENTE';
                                statusClass = 'alert-error';
                                explanation = `Criterio del Rapporto: $L \\approx ${formatNumber(L)} > 1$`;
                            }
                        }
                    } catch (e) {
                        results.push({
                            test: 'Criterio del Rapporto',
                            result: 'ERRORE',
                            value: 'Non calcolabile'
                        });
                    }

                    // Test 3: Criterio della Radice
                    try {
                        const roots = [];
                        const startIdx = Math.max(10, Math.floor(terms.length / 2));
                        for (let i = startIdx; i < Math.min(terms.length, startIdx + 20); i++) {
                            const n = (state.isPowerSeries ? 0 : 1) + i; // Indice corretto
                            if (Math.abs(terms[i]) > 1e-100) {
                                roots.push(Math.pow(Math.abs(terms[i]), 1 / n));
                            }
                        }

                        if (roots.length > 0) {
                            const L = roots.reduce((a, b) => a + b, 0) / roots.length;
                            results.push({
                                test: 'Criterio della Radice',
                                result: L < 1 ? 'CONVERGENTE' : (L > 1 ? 'DIVERGENTE' : 'INCONCLUSIVO'),
                                value: `L ‚âà ${formatNumber(L)}`
                            });

                            if (overallStatus === 'INCONCLUSIVO') {
                                if (L < 0.95) {
                                    overallStatus = 'CONVERGENTE';
                                    statusClass = 'alert-success';
                                    explanation = `Criterio della Radice: $L \\approx ${formatNumber(L)} < 1$`;
                                } else if (L > 1.05) {
                                    overallStatus = 'DIVERGENTE';
                                    statusClass = 'alert-error';
                                    explanation = `Criterio della Radice: $L \\approx ${formatNumber(L)} > 1$`;
                                }
                            }
                        }
                    } catch (e) {
                        results.push({
                            test: 'Criterio della Radice',
                            result: 'ERRORE',
                            value: 'Non calcolabile'
                        });
                    }
                }
            }

            // Verifica convergenza grafica (variazione ultimi valori)
            if (overallStatus === 'INCONCLUSIVO' && partialSums.length > 10) {
                const lastSums = partialSums.slice(-10);
                const variation = Math.abs(lastSums[lastSums.length - 1] - lastSums[0]);
                if (variation < 0.01) {
                    overallStatus = 'PROBABILMENTE CONVERGENTE';
                    statusClass = 'alert-success';
                    explanation = `Somme parziali stabilizzate (variazione ultimi 10: ${formatNumber(variation)})`;
                }
            }

            if (!explanation) {
                explanation = 'I criteri disponibili non forniscono informazioni conclusive sulla convergenza.';
            }

            // Aggiorna UI
            const indicator = document.getElementById('convergence-indicator');
            indicator.innerHTML = `
                <div class="alert ${statusClass}">
                    <strong>${overallStatus}</strong><br>
                    <span style="font-weight: normal; font-size: 13px;">${explanation}</span>
                </div>
            `;

            // Aggiorna spiegazione didattica
            const explanationContent = document.getElementById('explanation-content');
            explanationContent.innerHTML = generateDidacticExplanation(state.expression, isAlternating, state.isPowerSeries);

            const testOutput = document.getElementById('test-output');
            testOutput.innerHTML = results.map(r => `
                <div class="result-item">
                    <div class="result-label">${r.test}</div>
                    <div class="result-value">${r.result}</div>
                    <div class="help-text">${r.value}</div>
                </div>
            `).join('');

            renderMath();
        }        // ============================================
        // FUNZIONI UTILITY
        // ============================================

        function generateDidacticExplanation(expression, isAlternating, isPowerSeries) {
            let explanation = '<div style="line-height: 1.8;">';

            // Determina il tipo di serie
            if (isPowerSeries) {
                explanation += '<h4 style="margin-bottom: 12px; color: var(--color-primary);">üìö Serie di Potenze</h4>';
                explanation += '<p><strong>Definizione:</strong> Una serie di potenze ha la forma $\\sum_{n=0}^{\\infty} a_n x^n$ o $\\sum_{n=0}^{\\infty} a_n (x-c)^n$.</p>';

                // Spiegazioni per serie specifiche
                if (expression.includes('factorial(n)') && !expression.includes('2*n')) {
                    explanation += '<p><strong>Serie corrente:</strong> Serie esponenziale $e^x = \\sum_{n=0}^{\\infty} \\frac{x^n}{n!}$</p>';
                    explanation += '<p>Questa serie <strong>converge per ogni valore di x</strong> (raggio di convergenza $R = \\infty$).</p>';
                    explanation += '<p><strong>Criterio applicabile:</strong> Criterio del Rapporto. Il rapporto tra termini consecutivi √® $\\frac{|a_{n+1}|}{|a_n|} = \\frac{|x|}{n+1} \\to 0 < 1$.</p>';
                } else if (expression.includes('2*n+1') && expression.includes('factorial')) {
                    explanation += '<p><strong>Serie corrente:</strong> Serie di Taylor del seno $\\sin(x) = \\sum_{n=0}^{\\infty} \\frac{(-1)^n x^{2n+1}}{(2n+1)!}$</p>';
                    explanation += '<p>Serie <strong>convergente per ogni x</strong>. √à una serie alternata a termini decrescenti.</p>';
                    explanation += '<p><strong>Criteri applicabili:</strong> Criterio di Leibniz (serie alternata) e Criterio del Rapporto.</p>';
                } else if (expression.includes('2*n)') && expression.includes('factorial')) {
                    explanation += '<p><strong>Serie corrente:</strong> Serie di Taylor del coseno $\\cos(x) = \\sum_{n=0}^{\\infty} \\frac{(-1)^n x^{2n}}{(2n)!}$</p>';
                    explanation += '<p>Serie <strong>convergente per ogni x</strong>. √à una serie alternata a termini decrescenti.</p>';
                    explanation += '<p><strong>Criteri applicabili:</strong> Criterio di Leibniz (serie alternata) e Criterio del Rapporto.</p>';
                } else if (expression.includes('(n+1)') && expression.includes('x^(n+1)')) {
                    explanation += '<p><strong>Serie corrente:</strong> Serie di Taylor del logaritmo $\\ln(1+x) = \\sum_{n=0}^{\\infty} \\frac{(-1)^n x^{n+1}}{n+1}$</p>';
                    explanation += '<p>Serie convergente per $-1 < x \\leq 1$ (raggio di convergenza $R = 1$).</p>';
                    explanation += '<p><strong>Criterio applicabile:</strong> Criterio di Leibniz per $x > 0$ (serie alternata convergente).</p>';
                } else {
                    explanation += '<p><strong>Propriet√†:</strong> Le serie di potenze hanno un <em>raggio di convergenza</em> $R$ tale che:</p>';
                    explanation += '<ul><li>Convergono assolutamente per $|x| < R$</li>';
                    explanation += '<li>Divergono per $|x| > R$</li>';
                    explanation += '<li>Richiedono analisi specifica per $|x| = R$</li></ul>';
                }
            } else {
                explanation += '<h4 style="margin-bottom: 12px; color: var(--color-primary);">üìö Serie Numerica</h4>';
                explanation += '<p><strong>Definizione:</strong> Una serie numerica ha la forma $\\sum_{n=1}^{\\infty} a_n$ con termini costanti (non dipendenti da x).</p>';

                // Spiegazioni per serie specifiche
                if (expression === '1/n') {
                    explanation += '<p><strong>Serie corrente:</strong> Serie Armonica $\\sum_{n=1}^{\\infty} \\frac{1}{n}$</p>';
                    explanation += '<p>Questa serie √® <strong>DIVERGENTE</strong> nonostante $\\lim_{n\\to\\infty} \\frac{1}{n} = 0$.</p>';
                    explanation += '<p><strong>Criterio applicabile:</strong> Criterio del confronto o criterio integrale (confronto con $\\int_1^\\infty \\frac{1}{x}dx = \\infty$).</p>';
                } else if (expression === '(-1)^(n+1)/n') {
                    explanation += '<p><strong>Serie corrente:</strong> Serie Armonica Alternata $\\sum_{n=1}^{\\infty} \\frac{(-1)^{n+1}}{n}$</p>';
                    explanation += '<p>Questa serie √® <strong>CONVERGENTE</strong> (converge a $\\ln(2)$) per il Criterio di Leibniz.</p>';
                    explanation += '<p><strong>Criterio applicabile:</strong> Criterio di Leibniz: termini alternati, decrescenti in valore assoluto, tendenti a zero.</p>';
                } else if (expression.includes('1/n^')) {
                    const p = expression.match(/1\/n\^(\d+)/)?.[1] || '2';
                    explanation += `<p><strong>Serie corrente:</strong> Serie p-Armonica $\\sum_{n=1}^{\\infty} \\frac{1}{n^{${p}}}$</p>`;
                    explanation += `<p>Converge se $p > 1$, diverge se $p \\leq 1$. Nel tuo caso: $p = ${p}$.</p>`;
                    explanation += '<p><strong>Criterio applicabile:</strong> Criterio integrale o criterio del confronto.</p>';
                } else if (expression.includes('^n')) {
                    explanation += '<p><strong>Serie corrente:</strong> Serie Geometrica (se della forma $ar^n$)</p>';
                    explanation += '<p>Una serie geometrica $\\sum_{n=0}^{\\infty} ar^n$ converge se e solo se $|r| < 1$.</p>';
                    explanation += '<p><strong>Criterio applicabile:</strong> Criterio del Rapporto.</p>';
                } else if (isAlternating) {
                    explanation += '<p><strong>Serie corrente:</strong> Serie Alternata</p>';
                    explanation += '<p>Una serie i cui termini hanno segni alterni: $\\sum_{n=1}^{\\infty} (-1)^n a_n$ o $\\sum_{n=1}^{\\infty} (-1)^{n+1} a_n$.</p>';
                    explanation += '<p><strong>Criterio applicabile:</strong> Criterio di Leibniz (se $a_n$ decrescente e $\\lim a_n = 0$).</p>';
                } else {
                    explanation += '<p><strong>Propriet√† generali:</strong></p>';
                    explanation += '<ul><li><strong>Condizione necessaria:</strong> Se $\\sum a_n$ converge, allora $\\lim_{n\\to\\infty} a_n = 0$</li>';
                    explanation += '<li>Il viceversa NON √® vero (es: serie armonica)</li></ul>';
                }
            }

            // Spiegazione dei criteri principali
            explanation += '<hr style="margin: 16px 0; border: none; border-top: 1px solid var(--color-border);">';
            explanation += '<h4 style="margin-bottom: 12px; color: var(--color-primary);">üîç Criteri di Convergenza Utilizzati</h4>';

            explanation += '<p><strong>1. Condizione Necessaria:</strong> Verifica se $\\lim_{n\\to\\infty} a_n = 0$. Se questa condizione non √® soddisfatta, la serie diverge.</p>';

            if (isAlternating) {
                explanation += '<p><strong>2. Criterio di Leibniz:</strong> Per serie alternate $\\sum (-1)^n a_n$, se:</p>';
                explanation += '<ul><li>$a_n$ √® decrescente</li><li>$\\lim_{n\\to\\infty} a_n = 0$</li></ul>';
                explanation += '<p>allora la serie <strong>converge</strong> e l\'errore √® $|R_N| \\leq a_{N+1}$.</p>';
            }

            explanation += '<p><strong>' + (isAlternating ? '3' : '2') + '. Criterio del Rapporto:</strong> Calcola $L = \\lim_{n\\to\\infty} \\frac{|a_{n+1}|}{|a_n|}$:</p>';
            explanation += '<ul><li>Se $L < 1$: serie <strong>convergente</strong></li>';
            explanation += '<li>Se $L > 1$: serie <strong>divergente</strong></li>';
            explanation += '<li>Se $L = 1$: test <strong>inconclusivo</strong></li></ul>';

            explanation += '<p><strong>' + (isAlternating ? '4' : '3') + '. Criterio della Radice:</strong> Calcola $L = \\lim_{n\\to\\infty} \\sqrt[n]{|a_n|}$:</p>';
            explanation += '<ul><li>Se $L < 1$: serie <strong>convergente</strong></li>';
            explanation += '<li>Se $L > 1$: serie <strong>divergente</strong></li>';
            explanation += '<li>Se $L = 1$: test <strong>inconclusivo</strong></li></ul>';

            explanation += '</div>';
            return explanation;
        }

        function checkAlternating(terms) {
            if (terms.length < 3) return false;
            let alternates = true;
            for (let i = 1; i < Math.min(terms.length, 20); i++) {
                if (terms[i] * terms[i - 1] >= 0) {
                    alternates = false;
                    break;
                }
            }
            return alternates;
        }

        function formatNumber(num) {
            if (Math.abs(num) < 1e-10) return '0';
            if (Math.abs(num) > 1e6 || Math.abs(num) < 1e-3) {
                return num.toExponential(4);
            }
            return num.toFixed(6);
        }

        function renderMath() {
            renderMathInElement(document.body, {
                delimiters: [
                    { left: '$$', right: '$$', display: true },
                    { left: '$', right: '$', display: false },
                    { left: '\\[', right: '\\]', display: true },
                    { left: '\\(', right: '\\)', display: false }
                ],
                throwOnError: false
            });
        }

        // ============================================
        // UX: BADGES E STIMA RAGGIO DI CONVERGENZA
        // ============================================
        function updateTypeBadges() {
            const typeBadge = document.getElementById('type-badge');
            const radiusBadge = document.getElementById('radius-badge');
            const xStatusBadge = document.getElementById('x-status-badge');

            if (!typeBadge) return; // nel caso l'elemento non esista ancora

            if (state.isPowerSeries) {
                typeBadge.textContent = 'Tipo rilevato: Serie di potenze';
                typeBadge.className = 'badge badge-info';
                radiusBadge.classList.remove('hidden');
                xStatusBadge.classList.remove('hidden');
            } else {
                typeBadge.textContent = 'Tipo rilevato: Serie numerica';
                typeBadge.className = 'badge badge-info';
                radiusBadge.classList.add('hidden');
                xStatusBadge.classList.add('hidden');
            }
        }

        function estimatePowerSeriesRadius() {
            // Stima numerica: cerchiamo il massimo r tale che L(r) = avg_n |a_{n+1}(r)/a_n(r)| < 1
            // Nota: saltiamo r=0 (rapporti 0/0) e ignoriamo campioni NaN/Inf.
            try {
                const maxR = 5;
                const step = 0.1;
                const startR = 1e-3;
                let lastGood = 0;
                for (let r = startR; r <= maxR + 1e-12; r += step) {
                    const L = evaluateRatioLimit(r);
                    if (!isFinite(L) || isNaN(L)) {
                        // prova a continuare con un r diverso
                        continue;
                    }
                    if (L < 1) {
                        lastGood = r;
                    } else {
                        // abbiamo superato il raggio: fermiamoci
                        break;
                    }
                }
                state.radiusEstimate = lastGood;
                const radiusBadge = document.getElementById('radius-badge');
                if (radiusBadge) {
                    const label = (lastGood >= maxR - 1e-9) ? `R ‚â• ${maxR}` : `R ‚âà ${lastGood.toFixed(2)}`;
                    radiusBadge.textContent = label;
                    radiusBadge.title = 'Stima numerica di R: si cerca il massimo r per cui il criterio del rapporto fornisce L(r) < 1. Se si raggiunge il limite di scansione, R viene riportato come valore minimo garantito.';
                }
                updateXStatusBadge();
            } catch (e) {
                // Non bloccare l'UI in caso di errore
            }
        }

        function evaluateRatioLimit(xVal) {
            // Calcola il valore medio dei rapporti |a_{n+1}(x)/a_n(x)| su n in una finestra finale
            const Nsample = Math.max(50, Math.min(200, state.N));
            const start = Math.max(10, Nsample - 30);
            const ratios = [];
            for (let n = start; n < Nsample; n++) {
                try {
                    const a_n = state.compiledNode.evaluate({ n, x: xVal });
                    const a_np1 = state.compiledNode.evaluate({ n: n + 1, x: xVal });
                    if (isFinite(a_n) && isFinite(a_np1) && Math.abs(a_n) > 1e-100) {
                        const ratio = Math.abs(a_np1 / a_n);
                        if (isFinite(ratio)) ratios.push(ratio);
                    }
                } catch {
                    // salta
                }
            }
            if (ratios.length === 0) return NaN;
            return ratios.reduce((a, b) => a + b, 0) / ratios.length;
        }

        function updateXStatusBadge() {
            if (!state.isPowerSeries) return;
            const xStatusBadge = document.getElementById('x-status-badge');
            if (!xStatusBadge) return;
            const L = evaluateRatioLimit(state.x);
            if (!isFinite(L) || isNaN(L)) {
                xStatusBadge.textContent = `x=${state.x.toFixed(2)}: inconclusivo`;
                xStatusBadge.className = 'badge badge-warning';
                return;
            }
            if (L < 0.98) {
                xStatusBadge.textContent = `x=${state.x.toFixed(2)}: Converge (L‚âà${L.toFixed(3)})`;
                xStatusBadge.className = 'badge badge-success';
            } else if (L > 1.02) {
                xStatusBadge.textContent = `x=${state.x.toFixed(2)}: Diverge (L‚âà${L.toFixed(3)})`;
                xStatusBadge.className = 'badge badge-error';
            } else {
                xStatusBadge.textContent = `x=${state.x.toFixed(2)}: Inconclusivo (L‚âà${L.toFixed(3)})`;
                xStatusBadge.className = 'badge badge-warning';
            }
        }

        // ============================================
        // ESPORTAZIONE CSV
        // ============================================
        function exportCSV() {
            try {
                const { terms, partialSums } = calculateSeriesData(state.N, state.x);

                let csv = 'N,a_N,S_N\n';
                for (let i = 0; i < terms.length; i++) {
                    csv += `${i + 1},${terms[i]},${partialSums[i]}\n`;
                }

                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `serie_${state.expression.replace(/[^a-z0-9]/gi, '_')}_N${state.N}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                alert('Errore durante l\'esportazione: ' + error.message);
            }
        }

        // ============================================
        // GESTIONE MODALI
        // ============================================
        function openModal(modalId) {
            const modal = document.getElementById(modalId);
            modal.classList.add('show');
            document.body.style.overflow = 'hidden';
            // Renderizza le formule matematiche nel modale
            setTimeout(() => renderMath(), 100);
        }

        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            modal.classList.remove('show');
            document.body.style.overflow = 'auto';
        }

        function setupModalListeners() {
            // Event listeners per aprire i modali
            document.getElementById('open-series-modal').addEventListener('click', () => openModal('series-theory-modal'));
            document.getElementById('open-taylor-modal').addEventListener('click', () => openModal('taylor-theory-modal'));

            // Chiusura modali
            document.querySelectorAll('.close-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const modal = e.target.closest('.modal');
                    closeModal(modal.id);
                });
            });

            // Chiusura cliccando fuori dal modale
            document.querySelectorAll('.modal').forEach(modal => {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        closeModal(modal.id);
                    }
                });
            });

            // Chiusura con tasto ESC
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    document.querySelectorAll('.modal.show').forEach(modal => {
                        closeModal(modal.id);
                    });
                }
            });
        }

        // ============================================
        // AVVIO APPLICAZIONE
        // ============================================
        window.addEventListener('DOMContentLoaded', () => {
            init();
            setupModalListeners();
        });
    </script>

    <!-- Modale Teoria Serie Numeriche -->
    <div id="series-theory-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üìö Teoria delle Serie Numeriche</h2>
                <button class="close-btn" aria-label="Chiudi modale">&times;</button>
            </div>
            <div class="modal-body">
                <h3>Definizione di Serie Numerica</h3>
                <p>
                    Una <strong>serie numerica</strong> √® la somma degli infiniti termini di una successione $(a_n)$:
                </p>
                <div class="formula-box">
                    $$\sum_{n=1}^{\infty} a_n = a_1 + a_2 + a_3 + \cdots$$
                </div>
                <p>
                    La <strong>somma parziale</strong> $N$-esima √® definita come:
                </p>
                <div class="formula-box">
                    $$S_N = \sum_{n=1}^{N} a_n$$
                </div>
                <p>
                    La serie <strong>converge</strong> a un valore $S$ se:
                </p>
                <div class="formula-box">
                    $$\lim_{N \to \infty} S_N = S$$
                </div>

                <h3>Condizione Necessaria per la Convergenza</h3>
                <div class="theorem-box">
                    <p><strong>Teorema:</strong> Se la serie $\sum a_n$ converge, allora:</p>
                    <div class="formula-box">
                        $$\lim_{n \to \infty} a_n = 0$$
                    </div>
                    <p><strong>Importante:</strong> Questa √® una condizione <em>necessaria ma non sufficiente</em>.
                        Se il limite non √® zero, la serie diverge sicuramente. Ma se il limite √® zero, la serie potrebbe
                        convergere o divergere.</p>
                </div>
                <div class="example-box">
                    <p><strong>Controesempio:</strong> La serie armonica $\sum \frac{1}{n}$ ha $\lim_{n\to\infty}
                        \frac{1}{n} = 0$,
                        ma la serie <strong>diverge</strong>.</p>
                </div>

                <h3>Criteri di Convergenza</h3>

                <h4>1. Criterio del Confronto</h4>
                <p>Date due serie $\sum a_n$ e $\sum b_n$ con $0 \leq a_n \leq b_n$ definitivamente:</p>
                <ul>
                    <li>Se $\sum b_n$ converge, allora anche $\sum a_n$ converge</li>
                    <li>Se $\sum a_n$ diverge, allora anche $\sum b_n$ diverge</li>
                </ul>
                <p><strong>Applicabilit√†:</strong> Solo per serie a termini positivi.</p>

                <h4>2. Criterio del Rapporto (d'Alembert)</h4>
                <p>Sia $L = \lim_{n \to \infty} \left|\frac{a_{n+1}}{a_n}\right|$. Allora:</p>
                <ul>
                    <li>Se $L < 1$: la serie <strong>converge assolutamente</strong></li>
                    <li>Se $L > 1$: la serie <strong>diverge</strong></li>
                    <li>Se $L = 1$: il criterio √® <strong>inconclusivo</strong></li>
                </ul>
                <p><strong>Applicabilit√†:</strong> Serie generali (anche a termini di segno variabile).</p>
                <div class="example-box">
                    <p><strong>Esempio:</strong> Per $\sum \frac{x^n}{n!}$ si ha $L = \lim_{n\to\infty} \frac{|x|}{n+1}
                        = 0 < 1$, quindi converge per ogni $x$.</p>
                </div>

                <h4>3. Criterio della Radice (Cauchy)</h4>
                <p>Sia $L = \lim_{n \to \infty} \sqrt[n]{|a_n|}$. Allora:</p>
                <ul>
                    <li>Se $L < 1$: la serie <strong>converge assolutamente</strong></li>
                    <li>Se $L > 1$: la serie <strong>diverge</strong></li>
                    <li>Se $L = 1$: il criterio √® <strong>inconclusivo</strong></li>
                </ul>
                <p><strong>Applicabilit√†:</strong> Serie generali, particolarmente utile per serie con potenze.</p>

                <h4>4. Criterio di Leibniz (Serie Alternate)</h4>
                <p>Una serie alternata $\sum (-1)^n a_n$ con $a_n > 0$ converge se:</p>
                <ul>
                    <li>$(a_n)$ √® decrescente: $a_{n+1} \leq a_n$</li>
                    <li>$\lim_{n \to \infty} a_n = 0$</li>
                </ul>
                <p><strong>Applicabilit√†:</strong> Solo per serie con termini di segno alternato.</p>
                <div class="example-box">
                    <p><strong>Esempio:</strong> $\sum \frac{(-1)^n}{n}$ converge per Leibniz (serie armonica
                        alternata).</p>
                </div>

                <h4>5. Criterio dell'Integrale</h4>
                <p>Se $f(x)$ √® positiva, continua e decrescente per $x \geq 1$, allora:</p>
                <div class="formula-box">
                    $$\sum_{n=1}^{\infty} f(n) \text{ e } \int_1^{\infty} f(x)\,dx$$
                </div>
                <p>hanno lo stesso carattere (entrambe convergono o entrambe divergono).</p>
                <p><strong>Applicabilit√†:</strong> Serie a termini positivi con funzione integrabile associata.</p>

                <h3>Convergenza Assoluta e Condizionata</h3>
                <p>Una serie $\sum a_n$ converge <strong>assolutamente</strong> se $\sum |a_n|$ converge.</p>
                <div class="theorem-box">
                    <p><strong>Teorema:</strong> Se una serie converge assolutamente, allora converge anche nel senso
                        ordinario.</p>
                    <p>Il viceversa non √® vero: una serie pu√≤ convergere senza convergere assolutamente
                        (convergenza <strong>condizionata</strong>).</p>
                </div>

                <h3>Serie Notevoli</h3>
                <h4>Serie Geometrica</h4>
                <div class="formula-box">
                    $$\sum_{n=0}^{\infty} q^n = \frac{1}{1-q} \quad \text{se } |q| < 1$$ </div>
                        <p>Diverge se $|q| \geq 1$.</p>

                        <h4>Serie Armonica Generalizzata</h4>
                        <div class="formula-box">
                            $$\sum_{n=1}^{\infty} \frac{1}{n^p}$$
                        </div>
                        <ul>
                            <li>Converge se $p > 1$</li>
                            <li>Diverge se $p \leq 1$</li>
                        </ul>
                </div>
            </div>
        </div>

        <!-- Modale Teoria Serie di Taylor -->
        <div id="taylor-theory-modal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>üìê Teoria delle Serie di Taylor e MacLaurin</h2>
                    <button class="close-btn" aria-label="Chiudi modale">&times;</button>
                </div>
                <div class="modal-body">
                    <h3>Serie di Taylor</h3>
                    <p>
                        Data una funzione $f(x)$ infinitamente derivabile in un intorno di un punto $x_0$,
                        la <strong>serie di Taylor</strong> di $f$ centrata in $x_0$ √®:
                    </p>
                    <div class="formula-box">
                        $$f(x) = \sum_{n=0}^{\infty} \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n$$
                    </div>
                    <p>
                        Esplicitamente:
                    </p>
                    <div class="formula-box">
                        $$f(x) = f(x_0) + f'(x_0)(x-x_0) + \frac{f''(x_0)}{2!}(x-x_0)^2 + \frac{f'''(x_0)}{3!}(x-x_0)^3
                        + \cdots$$
                    </div>

                    <h3>Serie di MacLaurin</h3>
                    <p>
                        La <strong>serie di MacLaurin</strong> √® un caso particolare della serie di Taylor con $x_0 =
                        0$:
                    </p>
                    <div class="formula-box">
                        $$f(x) = \sum_{n=0}^{\infty} \frac{f^{(n)}(0)}{n!}x^n$$
                    </div>
                    <p>
                        Ovvero:
                    </p>
                    <div class="formula-box">
                        $$f(x) = f(0) + f'(0)x + \frac{f''(0)}{2!}x^2 + \frac{f'''(0)}{3!}x^3 + \cdots$$
                    </div>

                    <h3>Raggio di Convergenza</h3>
                    <p>
                        Una serie di potenze $\sum_{n=0}^{\infty} a_n x^n$ ha un <strong>raggio di convergenza</strong>
                        $R$
                        tale che:
                    </p>
                    <ul>
                        <li>La serie converge assolutamente per $|x| < R$</li>
                        <li>La serie diverge per $|x| > R$</li>
                        <li>Per $|x| = R$ il comportamento va studiato caso per caso</li>
                    </ul>
                    <p>Il raggio di convergenza pu√≤ essere calcolato con:</p>
                    <div class="formula-box">
                        $$\frac{1}{R} = \lim_{n \to \infty} \left|\frac{a_{n+1}}{a_n}\right| \quad \text{oppure} \quad
                        \frac{1}{R} = \lim_{n \to \infty} \sqrt[n]{|a_n|}$$
                    </div>
                    <p>
                        Nell'app, <em>la stima numerica di R</em> si ottiene cercando il massimo valore di $r$ per cui,
                        fissato $x=r$, la media sul tratto finale dei rapporti $\big|a_{n+1}(r)/a_n(r)\big|$ risulta
                        inferiore a 1. Se la stima raggiunge il limite superiore di scansione, mostriamo un
                        <strong>limite
                            inferiore</strong> (es. <code>R ‚â• 5</code>), che indica un raggio molto ampio (tipico di
                        $e^x$, $\sin x$, $\cos x$).
                        In precedenza, un caso limite per $x=0$ poteva produrre erroneamente <code>R ‚âà 0</code>; ora
                        viene
                        evitato saltando i campioni degeneri e partendo da un $r$ minimo positivo.
                    </p>

                    <h3>Sviluppi di MacLaurin Notevoli</h3>

                    <h4>1. Funzione Esponenziale</h4>
                    <div class="formula-box">
                        $$e^x = \sum_{n=0}^{\infty} \frac{x^n}{n!} = 1 + x + \frac{x^2}{2!} + \frac{x^3}{3!} + \cdots$$
                    </div>
                    <p><strong>Raggio di convergenza:</strong> $R = \infty$ (converge per ogni $x \in \mathbb{R}$)</p>
                    <div class="example-box">
                        <p><strong>Applicazione:</strong> Per $x = 1$ otteniamo $e = 1 + 1 + \frac{1}{2!} + \frac{1}{3!}
                            + \cdots \approx 2.71828$</p>
                    </div>

                    <h4>2. Funzione Seno</h4>
                    <div class="formula-box">
                        $$\sin(x) = \sum_{n=0}^{\infty} \frac{(-1)^n x^{2n+1}}{(2n+1)!} = x - \frac{x^3}{3!} +
                        \frac{x^5}{5!} - \frac{x^7}{7!} + \cdots$$
                    </div>
                    <p><strong>Raggio di convergenza:</strong> $R = \infty$</p>
                    <p><strong>Nota:</strong> Solo potenze dispari di $x$, coefficienti alternati.</p>

                    <h4>3. Funzione Coseno</h4>
                    <div class="formula-box">
                        $$\cos(x) = \sum_{n=0}^{\infty} \frac{(-1)^n x^{2n}}{(2n)!} = 1 - \frac{x^2}{2!} +
                        \frac{x^4}{4!} - \frac{x^6}{6!} + \cdots$$
                    </div>
                    <p><strong>Raggio di convergenza:</strong> $R = \infty$</p>
                    <p><strong>Nota:</strong> Solo potenze pari di $x$, coefficienti alternati.</p>

                    <h4>4. Logaritmo Naturale</h4>
                    <div class="formula-box">
                        $$\ln(1+x) = \sum_{n=1}^{\infty} \frac{(-1)^{n+1} x^n}{n} = x - \frac{x^2}{2} + \frac{x^3}{3} -
                        \frac{x^4}{4} + \cdots$$
                    </div>
                    <p><strong>Raggio di convergenza:</strong> $R = 1$ (converge per $-1 < x \leq 1$)</p>
                            <div class="example-box">
                                <p><strong>Attenzione:</strong> Questa serie non converge per $x > 1$ o $x \leq -1$.</p>
                            </div>

                            <h4>5. Funzione Binomiale</h4>
                            <div class="formula-box">
                                $$(1+x)^\alpha = \sum_{n=0}^{\infty} \binom{\alpha}{n} x^n = 1 + \alpha x +
                                \frac{\alpha(\alpha-1)}{2!}x^2 + \cdots$$
                            </div>
                            <p><strong>Raggio di convergenza:</strong> $R = 1$ (per $\alpha \notin \mathbb{N}$)</p>
                            <p>Dove $\binom{\alpha}{n} = \frac{\alpha(\alpha-1)\cdots(\alpha-n+1)}{n!}$ (coefficiente
                                binomiale generalizzato)</p>

                            <h4>6. Funzione Tangente Iperbolica</h4>
                            <div class="formula-box">
                                $$\frac{1}{1-x} = \sum_{n=0}^{\infty} x^n = 1 + x + x^2 + x^3 + \cdots$$
                            </div>
                            <p><strong>Raggio di convergenza:</strong> $R = 1$ (serie geometrica)</p>

                            <h3>Formula del Resto di Lagrange</h3>
                            <p>
                                L'errore commesso approssimando $f(x)$ con il polinomio di Taylor di grado $n$ √® dato
                                dal
                                <strong>resto di Lagrange</strong>:
                            </p>
                            <div class="formula-box">
                                $$R_n(x) = \frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1}$$
                            </div>
                            <p>dove $\xi$ √® un punto compreso tra $x_0$ e $x$.</p>
                            <p>
                                Questa formula permette di stimare l'errore di approssimazione e determinare quanti
                                termini
                                della serie sono necessari per raggiungere una precisione desiderata.
                            </p>

                            <h3>Applicazioni Pratiche</h3>
                            <ul>
                                <li><strong>Calcolo numerico:</strong> Approssimazione di funzioni trascendenti</li>
                                <li><strong>Fisica:</strong> Approssimazioni lineari e non lineari di fenomeni fisici
                                </li>
                                <li><strong>Ingegneria:</strong> Analisi di segnali e sistemi</li>
                                <li><strong>Statistica:</strong> Approssimazioni di distribuzioni di probabilit√†</li>
                            </ul>

                            <div class="theorem-box">
                                <p><strong>Teorema di Unicit√†:</strong> Se una funzione $f(x)$ √® sviluppabile in serie
                                    di potenze
                                    in un intorno di $x_0$, tale sviluppo coincide con la serie di Taylor di $f$ in
                                    $x_0$.</p>
                            </div>
                </div>
            </div>
        </div>
</body>

</html>