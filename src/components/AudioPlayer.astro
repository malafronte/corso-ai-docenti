---
const {
  src = "",
  ariaLabel = "Audio player",
  filename,
} = Astro.props as {
  src?: string;
  ariaLabel?: string;
  filename?: string;
};

// Resolve audioSrc server-side
let audioSrc: string = src;
if (!/^https?:\/\//i.test(src) && !src.startsWith("/")) {
  try {
    audioSrc = new URL(`../assets/audio-lessons/${src}`, import.meta.url).href;
  } catch (e) {
    audioSrc = src;
  }
}
const uid = `ap-${Math.random().toString(36).slice(2, 9)}`;
---

<div class="audio-player" data-audio-filename={filename || ""}>
  <audio
    id={`audio-${uid}`}
    controls
    src={audioSrc}
    aria-label={ariaLabel}
    preload="metadata"
    style="width:100%;max-width:560px;"
  >
    <source src={audioSrc} type="audio/mp4" />
    Your browser does not support the audio element.
  </audio>

  <script type="module">
    (function () {
      try {
        const script = document.currentScript;
        const container =
          script && script.closest && script.closest(".audio-player");
        if (!container) return;
        const audio = container.querySelector("audio");
        if (!audio) return;

        const title =
          container.dataset.audioFilename || document.title || "Audio";

        // Keep-alive timer per prevenire sospensione
        let keepAliveInterval = null;

        function startKeepAlive() {
          if (keepAliveInterval) return;

          // Aggiorna posizione ogni 5 secondi per mantenere attivo il player
          keepAliveInterval = setInterval(() => {
            if (!audio.paused) {
              updatePositionState();
            }
          }, 5000);
        }

        function stopKeepAlive() {
          if (keepAliveInterval) {
            clearInterval(keepAliveInterval);
            keepAliveInterval = null;
          }
        }



        function setupMediaSession() {
          if (!("mediaSession" in navigator)) return;
          try {
            const artworkUrl = container.dataset.audioPoster || "";
            const metadata = { title: title, artist: "", album: "" };
            if (artworkUrl)
              metadata.artwork = [
                { src: artworkUrl, sizes: "512x512", type: "image/png" },
              ];
            navigator.mediaSession.metadata = new MediaMetadata(metadata);

            navigator.mediaSession.setActionHandler("play", () => {
              audio.play().catch(() => {});
            });
            navigator.mediaSession.setActionHandler("pause", () => {
              audio.pause();
            });
            navigator.mediaSession.setActionHandler(
              "seekbackward",
              (details) => {
                const skip = (details && details.seekOffset) || 10;
                audio.currentTime = Math.max(0, audio.currentTime - skip);
                updatePositionState();
              }
            );
            navigator.mediaSession.setActionHandler(
              "seekforward",
              (details) => {
                const skip = (details && details.seekOffset) || 10;
                audio.currentTime = Math.min(
                  audio.duration || Infinity,
                  audio.currentTime + skip
                );
                updatePositionState();
              }
            );
            navigator.mediaSession.setActionHandler("seekto", (details) => {
              if (details && typeof details.seekTime === "number") {
                if (details.fastSeek && typeof audio.fastSeek === "function") {
                  audio.fastSeek(details.seekTime);
                } else {
                  audio.currentTime = details.seekTime;
                }
                updatePositionState();
              }
            });
            navigator.mediaSession.setActionHandler("stop", () => {
              audio.pause();
              audio.currentTime = 0;
              updatePositionState();
            });
          } catch (e) {
            /* ignore */
          }
        }

        function updatePositionState() {
          try {
            if (!("mediaSession" in navigator)) return;
            if (!navigator.mediaSession.setPositionState) return;

            // Ensure duration is a valid, positive number
            const duration = audio.duration;
            if (!Number.isFinite(duration) || duration <= 0) {
              return;
            }

            navigator.mediaSession.setPositionState({
              duration: duration,
              playbackRate: audio.playbackRate || 1,
              position: audio.currentTime || 0,
            });
          } catch (e) {
            /* ignore */
          }
        }

        // Event listeners per Media Session
        audio.addEventListener("play", () => {
          try {
            if (navigator.mediaSession)
              navigator.mediaSession.playbackState = "playing";
          } catch (e) {}
          // Avvia keep-alive
          startKeepAlive();
        });

        audio.addEventListener("pause", () => {
          try {
            if (navigator.mediaSession)
              navigator.mediaSession.playbackState = "paused";
          } catch (e) {}
          // Ferma keep-alive
          stopKeepAlive();
        });

        audio.addEventListener("timeupdate", () => updatePositionState());
        audio.addEventListener("seeked", () => updatePositionState());

        audio.addEventListener("loadedmetadata", () => {
          updatePositionState();
          setupMediaSession();
        });

        audio.addEventListener("ended", () => {
          try {
            if (navigator.mediaSession)
              navigator.mediaSession.playbackState = "none";
          } catch (e) {}
          // Ferma keep-alive
          stopKeepAlive();
        });

        // Setup media session on first user play
        const onFirstPlay = () => {
          audio.removeEventListener("play", onFirstPlay);
          setupMediaSession();
        };
        audio.addEventListener("play", onFirstPlay);

        if (audio.readyState >= 1) {
          updatePositionState();
          setupMediaSession();
        }

        // Cleanup quando il componente viene rimosso
        window.addEventListener("beforeunload", () => {
          stopKeepAlive();
        });
      } catch (e) {
        console.error("Errore nel componente AudioPlayer:", e);
      }
    })();
  </script>
</div>

<style>
  .audio-player {
    margin: 0.75rem 0 1.25rem 0;
  }
</style>
