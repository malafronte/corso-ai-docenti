---
const {
  src = "",
  ariaLabel = "Audio player",
  filename,
} = Astro.props as {
  src?: string;
  ariaLabel?: string;
  filename?: string;
};

// Resolve audioSrc server-side
let audioSrc: string = src;
if (!/^https?:\/\//i.test(src) && !src.startsWith("/")) {
  try {
    audioSrc = new URL(`../assets/audio-lessons/${src}`, import.meta.url).href;
  } catch (e) {
    audioSrc = src;
  }
}
const uid = `ap-${Math.random().toString(36).slice(2, 9)}`;
---

<div class="audio-player" data-audio-filename={filename || ""}>
  <audio
    id={`audio-${uid}`}
    controls
    src={audioSrc}
    aria-label={ariaLabel}
    preload="auto"
    style="width:100%;max-width:560px;"
  >
    <source src={audioSrc} type="audio/mp4" />
    Your browser does not support the audio element.
  </audio>

  <script type="module">
    (function () {
      try {
        const script = document.currentScript;
        const container =
          script && script.closest && script.closest(".audio-player");
        if (!container) return;
        const audio = container.querySelector("audio");
        if (!audio) return;

        const title =
          container.dataset.audioFilename || document.title || "Audio";

        let positionUpdateInterval = null;
        let wakeLockSentinel = null;

        // Richiedi Wake Lock per impedire la sospensione (dove supportato)
        async function requestWakeLock() {
          try {
            if ("wakeLock" in navigator) {
              wakeLockSentinel = await navigator.wakeLock.request("screen");
              wakeLockSentinel.addEventListener("release", () => {
                console.log("Wake Lock rilasciato");
              });
            }
          } catch (err) {
            console.log("Wake Lock non disponibile:", err);
          }
        }

        // Rilascia Wake Lock
        function releaseWakeLock() {
          if (wakeLockSentinel) {
            wakeLockSentinel.release().then(() => {
              wakeLockSentinel = null;
            });
          }
        }

        // Aggiorna la posizione più frequentemente durante la riproduzione
        function startPositionUpdates() {
          if (positionUpdateInterval) return;

          // Aggiorna ogni 1 secondo per mantenere lo slider sincronizzato
          positionUpdateInterval = setInterval(() => {
            if (!audio.paused) {
              updatePositionState();
            }
          }, 1000);
        }

        function stopPositionUpdates() {
          if (positionUpdateInterval) {
            clearInterval(positionUpdateInterval);
            positionUpdateInterval = null;
          }
        }

        function setupMediaSession() {
          if (!("mediaSession" in navigator)) return;
          try {
            const artworkUrl = container.dataset.audioPoster || "";
            const metadata = {
              title: title,
              artist: "",
              album: "",
            };

            if (artworkUrl) {
              metadata.artwork = [
                { src: artworkUrl, sizes: "96x96", type: "image/png" },
                { src: artworkUrl, sizes: "128x128", type: "image/png" },
                { src: artworkUrl, sizes: "192x192", type: "image/png" },
                { src: artworkUrl, sizes: "256x256", type: "image/png" },
                { src: artworkUrl, sizes: "384x384", type: "image/png" },
                { src: artworkUrl, sizes: "512x512", type: "image/png" },
              ];
            }

            navigator.mediaSession.metadata = new MediaMetadata(metadata);

            // Handler per play
            navigator.mediaSession.setActionHandler("play", () => {
              audio.play().catch(() => {});
            });

            // Handler per pause
            navigator.mediaSession.setActionHandler("pause", () => {
              audio.pause();
            });

            // Handler per seek backward
            navigator.mediaSession.setActionHandler(
              "seekbackward",
              (details) => {
                const skip = (details && details.seekOffset) || 10;
                audio.currentTime = Math.max(0, audio.currentTime - skip);
                updatePositionState();
              }
            );

            // Handler per seek forward
            navigator.mediaSession.setActionHandler(
              "seekforward",
              (details) => {
                const skip = (details && details.seekOffset) || 10;
                audio.currentTime = Math.min(
                  audio.duration || Infinity,
                  audio.currentTime + skip
                );
                updatePositionState();
              }
            );

            // CRITICO: Handler per seekto (permette di trascinare lo slider)
            navigator.mediaSession.setActionHandler("seekto", (details) => {
              if (details && typeof details.seekTime === "number") {
                audio.currentTime = details.seekTime;
                updatePositionState();
              }
            });

            // Handler per stop
            navigator.mediaSession.setActionHandler("stop", () => {
              audio.pause();
              audio.currentTime = 0;
              updatePositionState();
            });

            // Handler per previous/next track (opzionale, impedisce errori)
            navigator.mediaSession.setActionHandler("previoustrack", null);
            navigator.mediaSession.setActionHandler("nexttrack", null);
          } catch (e) {
            console.warn("Errore setup Media Session:", e);
          }
        }

        function updatePositionState() {
          try {
            if (!("mediaSession" in navigator)) return;
            if (!navigator.mediaSession.setPositionState) return;

            const duration = audio.duration;
            // Verifica che la durata sia valida
            if (!Number.isFinite(duration) || duration <= 0) {
              return;
            }

            const position = Math.min(audio.currentTime || 0, duration);
            const playbackRate = audio.playbackRate || 1;

            navigator.mediaSession.setPositionState({
              duration: duration,
              playbackRate: playbackRate,
              position: position,
            });
          } catch (e) {
            // Ignora errori se l'API non è supportata completamente
          }
        }

        // Event listener per play
        audio.addEventListener("play", () => {
          try {
            if (navigator.mediaSession) {
              navigator.mediaSession.playbackState = "playing";
            }
          } catch (e) {}

          startPositionUpdates();
          requestWakeLock();
        });

        // Event listener per pause
        audio.addEventListener("pause", () => {
          try {
            if (navigator.mediaSession) {
              navigator.mediaSession.playbackState = "paused";
            }
          } catch (e) {}

          stopPositionUpdates();
          releaseWakeLock();
        });

        // Event listener per ended
        audio.addEventListener("ended", () => {
          try {
            if (navigator.mediaSession) {
              navigator.mediaSession.playbackState = "none";
            }
          } catch (e) {}

          stopPositionUpdates();
          releaseWakeLock();
        });

        // Aggiorna posizione durante timeupdate
        audio.addEventListener("timeupdate", () => {
          updatePositionState();
        });

        // Aggiorna dopo seek manuale
        audio.addEventListener("seeked", () => {
          updatePositionState();
        });

        // Aggiorna quando cambia la durata
        audio.addEventListener("durationchange", () => {
          updatePositionState();
        });

        // Aggiorna quando cambiano i metadati
        audio.addEventListener("loadedmetadata", () => {
          updatePositionState();
        });

        // Setup iniziale quando i metadati sono pronti
        if (audio.readyState >= 1) {
          setupMediaSession();
          updatePositionState();
        } else {
          audio.addEventListener(
            "loadedmetadata",
            () => {
              setupMediaSession();
              updatePositionState();
            },
            { once: true }
          );
        }

        // Riprendi Wake Lock quando la pagina torna visibile
        document.addEventListener("visibilitychange", () => {
          if (document.visibilityState === "visible" && !audio.paused) {
            requestWakeLock();
          }
        });

        // Cleanup quando il componente viene rimosso
        window.addEventListener("beforeunload", () => {
          stopPositionUpdates();
          releaseWakeLock();
        });
      } catch (e) {
        console.error("Errore nel componente AudioPlayer:", e);
      }
    })();
  </script>
</div>

<style>
  .audio-player {
    margin: 0.75rem 0 1.25rem 0;
  }
</style>
